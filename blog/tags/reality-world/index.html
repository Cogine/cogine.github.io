<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-tags-post-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">3 posts tagged with &quot;Reality World&quot; | Creating an intelligent reality with AI</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://realityworld.com/img/website-preview-image.png"><meta data-rh="true" name="twitter:image" content="https://realityworld.com/img/website-preview-image.png"><meta data-rh="true" property="og:url" content="https://realityworld.com/blog/tags/reality-world"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" property="og:title" content="3 posts tagged with &quot;Reality World&quot; | Creating an intelligent reality with AI"><meta data-rh="true" name="docusaurus_tag" content="blog_tags_posts"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_tags_posts"><link data-rh="true" rel="icon" href="/img/logo/reality-world.svg"><link data-rh="true" rel="canonical" href="https://realityworld.com/blog/tags/reality-world"><link data-rh="true" rel="alternate" href="https://realityworld.com/blog/tags/reality-world" hreflang="en"><link data-rh="true" rel="alternate" href="https://realityworld.com/zh/blog/tags/reality-world" hreflang="zh"><link data-rh="true" rel="alternate" href="https://realityworld.com/blog/tags/reality-world" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Creating an intelligent reality with AI RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Creating an intelligent reality with AI Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="Creating an intelligent reality with AI JSON Feed"><link rel="stylesheet" href="/assets/css/styles.61ddffc2.css">
<link rel="preload" href="/assets/js/runtime~main.2fd98532.js" as="script">
<link rel="preload" href="/assets/js/main.2db48ae4.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,t("light"))}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><div class="announcementBar_mb4j" role="banner"><div class="content_knG7 announcementBarContent_xLdY"><a target="_blank" rel="nofollow noopener noreferrer" href="https://github.com/Cogine/RealityWorld">⭐ We are going open source on GitHub</a></div></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo/reality-world.svg" alt="Reality World" class="themedImage_ToTc themedImage--light_HNdA" height="32px" width="32px"><img src="/img/logo/reality-world.svg" alt="Reality World" class="themedImage_ToTc themedImage--dark_i4oU" height="32px" width="32px"></div><b class="navbar__title text--truncate">Reality World</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Products</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/cogine">Cogine</a></li><li><a class="dropdown__link" href="/reality-create">Reality Create</a></li><li><a class="dropdown__link" href="/app">Reality World</a></li><li><a class="dropdown__link" href="/self-deploying">Self-deploying</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Developers</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/whitepaper">Whitepaper</a></li><li><a class="dropdown__link" href="/docs/intro">Documentation</a></li><li><a class="dropdown__link" href="/thinking">Thinking</a></li></ul></div><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/features">Features &amp; Comparison</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>English</a><ul class="dropdown__menu"><li><a href="/blog/tags/reality-world" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en">English</a></li><li><a href="/zh/blog/tags/reality-world" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh">中文</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Community</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/community/about-open-source">About open source</a></li><li><a class="dropdown__link" href="/community/about-reality-world">About Reality World</a></li><li><a class="dropdown__link" href="/community/roadmap">Roadmap</a></li><li><a class="dropdown__link" href="/community/contact">Contact</a></li><li><a class="dropdown__link" href="/community/questions">Questions</a></li></ul></div><a href="https://github.com/Cogine/RealityWorld" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current,docs-community-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/reality-world-open-source-conference">Reality World 开源技术分享会</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/conversational-computing">Conversational computing: a new programming model empower LLM applications</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/thinking">对未来数字世界和软件构造的思考</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><header class="margin-bottom--xl"><h1>3 posts tagged with &quot;Reality World&quot;</h1><a href="/blog/tags">View All Tags</a></header><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="呃，这又是一个创业公司营销的噱头和方式吗？"><link itemprop="image" href="https://realityworld.com/img/blog/open-source-conference.jpg"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/reality-world-open-source-conference">Reality World 开源技术分享会</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-09T00:00:00.000Z" itemprop="datePublished">October 9, 2023</time> · <!-- -->28 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/ElvisQin" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/ElvisQin.png" alt="Chunlin Qin" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/ElvisQin" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Chunlin Qin</span></a></div><small class="avatar__subtitle" itemprop="description">Creator of Reality World</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p><strong>呃，这又是一个创业公司营销的噱头和方式吗？</strong></p><p><strong>又去看他们宣传产品不讲技术吗？</strong></p><p><strong>你直接开源不就得了，还搞什么线下活动？</strong></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="先回答问题">先回答问题<a href="#先回答问题" class="hash-link" aria-label="Direct link to 先回答问题" title="Direct link to 先回答问题">​</a></h2><p>关于第一个问题，<a href="https://realityworld.com/" target="_blank" rel="noopener noreferrer">Reality World</a>已经慎重决定由创业项目转为纯开源项目，也就是说它后面将不会有一个创业公司实体来运营，它会真正依靠社区及其组织进行发展，就像Bevy等开源项目，当然我肯定也会持续在这个项目进行迭代开发。这也意味着它不再有商业利益，任意公司或个人都可以使用或者基于它进行修改或扩展。</p><p><strong>之所以这样的选择，很大一个原因是，我觉得这几年技术、环境和产品形态的变化和发展都很快，各种概念弥漫着整个世界，我认识和交流过很多投资人、创业者、开发者以及行业很多不太懂技术的各种角色，即使最聪明的人，往往也很难在一些关于技术的理解上达成共识，而且国内的整个环境普遍还是更关注上层的应用，而硅谷的很多产品创新更多是源于对技术的深刻理解。所以我觉得站在这个历史阶段，我们最重要的是要有一些关于技术的基础讨论形成共识，要有一些具体而系统的实践而不是停留在臆想，然后要将这样的基础共识开放为公共资源，形成一些坚强的共识底座，然后有了更清晰的技术理解，上层的创新才会真正的繁荣。Reality World 现在的使命就是尝试去成为其中的一股开放力量，它首先提出自己对技术和未来的系统理解，然后基于这些理解构建一种可供大家学习和讨论的实践，最后开源出来供大家传播、分享、讨论和发展。</strong></p><p>关于第二个问题，如果有朋友参加过我2018年的全国图形渲染技术巡讲，一个人围绕一个主题讲3～4个小时，在中国这种会议几乎是绝无仅有的，那种系统和深度远不是那种15～45分钟蜻蜓点水一样的感觉，这将是一场非常深刻的技术旅程，我相信每个人可以学到非常非常多的知识和理解，后面我会大概说明会讲什么内容。</p><p>关于第三个问题，这个项目跟其它项目非常不同，简单来说，直接开源出来让大家自己研究代码和文档可能并不好理解，通常我自己有时候也很难用简单的几句话向朋友或投资人说明Reality World是什么。一方面是Reality World太技术，涉及的每一个设计决策都有很多不同层面的考虑；另一方面它涉及的技术面非常广，从程序的组织结构、到编译/解释/链接，到运行时的虚拟机、调度和沙盒，以及还涉及到怎样用这些技术去解决比如元宇宙应用的一些需求等等；最后它的目标也不是一个简单的应用或者一个框架，它是介于框架和编程语言之间的一种用于构建应用的软件构造方法，但它本身也不是一种编程语言。</p><p><strong>所以，这么多复杂的事情耦合在一起，我必须用语音和视频的方式才能更清晰的表达它，才能让大家更好地理解这个项目的目的，不然开源一个大家都看不懂或者连看懂目的都很复杂的项目有什么意义呢？但好消息是，如果你听我一次系统的讲解，它其实理解起来非常简单，但这种简单它不能用简单的文字表达，否则你可能要花费远远大于3个小时的时间才能更清晰的理解这个项目的逻辑和目的。</strong></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="reality-world是什么">Reality World是什么？<a href="#reality-world是什么" class="hash-link" aria-label="Direct link to Reality World是什么？" title="Direct link to Reality World是什么？">​</a></h2><p>尽管这个问题回答起来很困难，但我还是必须要尝试用简单的几句话解释它，否则都不知道它是何物，我为什么要去关注这个项目和参加这次活动呢？</p><p><a href="https://realityworld.com/" target="_blank" rel="noopener noreferrer">Reality World</a>是一个面向具有<strong>“未来特征”</strong>应用的开发框架和运行时，开发框架是指它是一个用于构建应用的工具，就像你用游戏引擎可以构建游戏程序，只不过现在它还不支持图形和UI显示，但是在将来它应该可以比较简单地集成一些渲染引擎或者UI框架，毕竟这部分的内容和工作流程大部分是比较成熟的，也可以很容易地把它嵌入到已有的游戏或者应用中，用于提供一些额外的功能。</p><p>所谓<strong>未来特征</strong>，我们主要指三个层面，后面会有更多讨论：</p><ul><li><strong>互操作性</strong></li><li><strong>相互协作</strong></li><li><strong>去中心化</strong></li></ul><p>实际上，这三个特性正对应着元宇宙（互操作性），大模型应用（多智能体协作）以及Web 3.0（去中心化）。尽管这三者之间的概念以及技术需求都是很模糊的，我们则尝试在这三者之间寻找一种统一的计算架构和软件构造方法。所以这就是Reality World技术上的复杂性，也就是为什么我们思考的是面向未来5~10年的应用的形态。</p><p>Reality World整个体系分为三个部分：</p><ul><li><strong>Cogine：</strong>是整个应用构建方法的底座和运行时，它定义这种应用的表述格式，以及对这种格式的动态解释和运行时的其它功能。该词的前缀 <em>co-</em> 取自<strong>Co</strong>mplexity system，或者<strong>Co</strong>gnitive computing，或者<strong>Co</strong>nversational computing，这些术语都是Cogine背后的一些技术思想；后缀 <em>-gine</em> 来自于En<strong>gine</strong>。所以可以称之为复杂引擎，认知计算引擎或者对话式计算引擎，其中复杂系统相关的一些理论是它重要的一些设计原则和目标。</li><li><strong>Reality Create：</strong>是这种应用的编辑器。</li><li><strong>Reality World：</strong>是这种应用的一个模拟器，任意一个基于Cogine定义的格式构建的应用程序包，都可以被它直接动态加载和运行。当然作为一个面向用户的应用程序，它还有其它一些功能，比如程序的安全授权管理，多程序的分组以及用户与程序的交互界面等等功能。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="讲什么">讲什么？<a href="#讲什么" class="hash-link" aria-label="Direct link to 讲什么？" title="Direct link to 讲什么？">​</a></h2><p>基本上，会分享所有关于Reality World的一切，包括它的为什么这么思考，具体的架构设计，以及一个具体的代码实现和Demo演示等。</p><p>计算机和数字化发展这么多年，我们已经积累了非常多的知识、理论和方法，从编程语言、软件工程到各种架构设计模式，而且几乎任何一种新的特别是偏底层的架构设计，往往都面临着跟其它很多模块的交互和协作，所以与单纯了解一种方法本身的知识相比，其背后的逻辑和设计思想有时候更为重要。</p><p>大体上，3~4个小时的演讲分为两个部分：</p><ul><li>约有40%的内容讨论为什么要这么设计</li><li>其它60%则介绍具有的架构设计及代码</li></ul><p>Reality World的目标，是要构建一种新的程序组织和构造的方法，所以最基础的问题就是为什么要构建一种新的方法？我们已经有非常成熟的各种体系，在传统的流程中，比如要构建一个应用程序，首先基本的各种编程语言如C++、Rust、Python、Javascript、C#、Go等基本上解决了大部分的逻辑组织和表达的问题，剩下的主要就是在显示层又会有不同的选择，比如要想实现3D的图形界面，至少得选择一个游戏引擎或者其它具有3D渲染能力的组件或者框架，2D的界面则有更多各式各样的选择，比如iOS和Android都有原生的UI交互框架，也有其它一些如React、Flutter等跨平台或者基于Web的各种框架。</p><p>因此这个其实是Reality World最核心要回答的问题。为什么要设计一种新的方法，我们将主要从两个层面来回答：</p><ul><li>外在层面</li><li>内在层面</li></ul><p><strong>外在层面</strong> 是指在编程语言和传统软件构造方法之外的需求，这部分也是更多对应40%的内容中为什么要这么设计的问题。过去几十年来应用构造的体系基本上都是围绕构建一个单一的程序体被隔离在单一的内存中运行的，在这种背景下，软件之间的功能通常都是相互隔离的，甚至即使是属于同一个用户不同应用之间的数据，虽然看起来都是同一个用户的数据，但是不同的软件之间却无法访问。这种机制在过去几十年都能够很好地解决我们的数字化的问题，直到Web 3.0和元宇宙的出现，这两种新的应用形态似乎都在尝试构建一个共享、互操作的数字世界。这要求应用之间需要高度交互能力，然而这种需求和传统的软件构造方法是天生相悖的，传统软件构造方法建立内存隔离的目的就是保护数据和内存中数据的安全，它的一个基本的安全底座就是系统的内存环境会保护程序内所有的数据，因此传统的编程语言和软件构造方法就没有太多专门针对这些数据的保护措施，但是当我们去掉这个内存保护，要求很多匿名的软件在一个内存环境中进行运行的时候，这种安全性怎么保证。虽然Web Assembly和一些容器等沙盒技术提供了一些解决方案，但是沙盒技术本身更多是为虚拟化而设计，它的主要方法也是建立模拟操作系统的内存保护机制。</p><p>因此，本质上针对这种新的需求，我们要重新思考软件构造方法本身。而要开发一种新的思路，我们就必须要很好地理解现有各种技术的原理及其问题，这里涉及的技术点比如编译器的寻址计算，内存机制，沙盒技术，USD/LLVM/MLIR等一些具有互操作和模块化能力的技术思想，虚拟机的作用，区块链中互操作性架构的一些思想。</p><p>除了外在的需求和驱动，现有的软件构造方法在 <strong>内在层面</strong> 也存在很多问题。一个现实的问题是编程仍然是一份门槛非常高的工作，全世界会编程的人不足0.5%，所以说我们今天的数字化的程度是远远不够的，因为剩下那么多群体能带来多少可能性是不可估量的。尽管现在有大模型这种提升编程效率的技术和方法，但是在软件构造方法本身没有变得更简单之前，也很难解决实质性的问题。</p><p>软件开发是由人去表达人类理解的逻辑流程，然而现代大部分编程语言的核心抽象都还是面向硬件和编译器的，我不是说编程语言一定要是自然语言，但是传统的编程语言中有很多的概念和规则都是面向计算机的。</p><p>首先，比如程序的数据管理是非常复杂的，你必须要定义数据被存放在哪里，怎么初始化，什么时候删除，当你需要执行某个具体逻辑的时候，往往需要搜集各种上下文以计算条件，这些数据充斥在各种结构各种对象中使用各种不同的方法进行封装。我们编程很多时间就是在组织这种数据，决定他们被怎样构造、初始化和存放才能使得获取它们变得更简单而灵活，而且这种结构也复杂往往越混乱，因为这些数据还对应着复杂的运行时状态，这样逻辑的执行就不光取决于数据，该取决于执行时它们的状态，这样你就不得不很好地维护它们正确的状态。</p><p>当一个程序员在思路TA代码中的逻辑跟TA思考现实生活中的某个事情时思路是完全不一样的，在现实中我们往往很少关注一个东西的位置我要把它放在哪里，我去访问的时候它们的组合状态对不对等，现实生活中的一切似乎都是那么自然，我们的精力都在关注事情的逻辑本身。</p><p>其次，程序的结构组织也是非常复杂的，我们人思路现实世界中的问题通常是线性的，先做什么再做什么，我们往往任意用流程图把它画出来，人与人之间的交流也非常简单。程序的流程则通常很难可视化，因为它的表达不是线性的，整个流程有点像一个深度优先的遍历算法，对于每一个开始的节点，它必须进入每个函数的调用链，直到所有的子函数调用都结束才会返回来执行下一步。就像我们人想事情是先把总体流程步骤想好，再去解决具体一个个细节问题，计算机程序是每做一件事情都需要把它的细节全部做完，然后开始下一件事情。你可以说每个函数内部在不去看系函数的时候也是线性的流程，但是你很难进行可视化，因为这些函数内部的细节，它们没有一些规范，函数的输入输出参数定义也不一样。更要命的是，你无法很轻易地对流程进行调试，比如想跳过、新增或者调整某些流程，这可能需要去修改源代码，而源代码通常不是注释那么简单，因为有些流程可能产生关联数据导致后面的流程根本就无法执行。</p><p>我把这个问题称为程序结构的问题，可见我们仍然无法用比较符合直觉的方法去构建逻辑流程。</p><p>所以我认为，编程这个事情的门槛，其实很大程度上并不是来源于编程语言本身，而是在与程序的结构组织和数据管理。这两个层面其实都是和编译器和硬件有关，正是因为编译器需要按照这样的方式编译为硬件可以执行的程序，所以编程语言才是这么设计。</p><p><strong>结合上述外在和内在的问题，Reality World的目标就是，通过深入分析程序构建和执行的整个过程，能不能设计出一种新的方法流程可以同时解决这两个问题。这就是我们这次技术分享会的重点内容</strong>。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="面向的受众群体是谁">面向的受众群体是谁？<a href="#面向的受众群体是谁" class="hash-link" aria-label="Direct link to 面向的受众群体是谁？" title="Direct link to 面向的受众群体是谁？">​</a></h2><p>本次活动主要面向两类人群：</p><ul><li>希望深入了解相关技术的开发人员</li><li>希望通过深入了解一些技术的思路来更好地理解一些新的技术概念的非技术人员</li></ul><p>对于技术人员，如果你关注以下技术，你可以来听听我的理解：</p><ul><li>游戏引擎架构</li><li>ECS/DOTS</li><li>USD</li><li>LLVM/MLIR</li><li>Rust</li><li>Web Assembly</li><li>编译、解释、链接过程</li><li>面向对象</li><li>函数式编程</li><li>LLM应用</li><li>元宇宙及互操作性</li><li>开放世界和复杂系统架构</li></ul><p>对于非技术人员，可以帮助你更好的理解以下技术概念：</p><ul><li>元宇宙</li><li>大模型应用架构</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="开源的目的是什么">开源的目的是什么？<a href="#开源的目的是什么" class="hash-link" aria-label="Direct link to 开源的目的是什么？" title="Direct link to 开源的目的是什么？">​</a></h2><p>我希望Reality World的开源可以实现以下几个目的：</p><ul><li><strong>为未来5-10年的数字世界基础架构的技术发展方向提供一种系统的视角</strong>，这个问题是非常复杂的，不光是技术本身就充满复杂性，要考虑很多问题，同时在认知上去理解也是非常复杂的，所以我们必须构建一套清晰的视角去理解这些问题，为后续的研究提供一些有价值的参考思路。</li><li><strong>为上述的架构体系提供一种可行且简易的技术实现方案</strong>，提出一种想法有时候看起来很容易，例如很多科技媒体也提出许多对于未来软件应用的畅想。但一套可行的技术方案涉及很多细节，例如你对现有技术体系进行怎样的调整，理由和必要性是什么，调整之后对其它模块的交互方式是怎样，调整之后怎样建立新的生态，用户怎样去学习等等，这一切后面涉及非常复杂的架构思考。所以我们必须有一个可行的技术实现方案，才能说明它的可行性，因此才具有参考价值。</li><li><strong>为程序员对技术的学习提供一些不同维度的理解</strong>，我们程序员终极一生的努力可能都是尝试去更好地理解软件构建的逻辑思维，因为软件的逻辑表达是极度复杂的，这种复杂性随着软件规模的增大而急剧上升。程序员应对这种挑战的最好方法，就是尽可能去更好地理解软件构造的逻辑。这种逻辑可能超出对一个技术本身作为工具属性的掌握，更要理解这些技术背后的思想，我认为掌握技术思想的衡量方式就是你有可能把它用于超出它本身被定义用来解决问题的范围，Reality World的设计和思考过程充满着大量的这类对技术的不同解读，相信能够提供很多不同的启示从而助力我们掌握技术背后的思想。</li><li><strong>借助社区的力量去挖掘这种新型技术架构能够支撑的产品形态</strong>，最近几年关于Web 3.0、元宇宙、以及大模型AI应用的持续不断出现，人们对未来数字化的预期会越来越大，未来的数字化形态必然会发生一些变化。但是目前很多因素糅合在一起使得我们很难去看到清楚的路径，这里面必然涉及到底层技术以及上层产品形态的相互驱动及进化，任何单一实体可能都很难从这种耦合中看到清晰的逻辑。所以Reality World聚焦于技术的思考，并将这些思考全部开源，然后不同的行业可以吸取这种思考去融入自己的产品思维，这样也许我们可以共同来理清未来的思路。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="license">License<a href="#license" class="hash-link" aria-label="Direct link to License" title="Direct link to License">​</a></h3><p>Reality World所有的源代码及其技术架构思路均采用非常宽松的MIT开源协议：</p><ul><li><a href="http://opensource.org/licenses/MIT" target="_blank" rel="noopener noreferrer">MIT license</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="开源什么">开源什么？<a href="#开源什么" class="hash-link" aria-label="Direct link to 开源什么？" title="Direct link to 开源什么？">​</a></h2><p>基本上，Reality World相关的所有一切都会开源，包括：</p><ul><li>核心代码</li><li>整理手稿：大概20多万字我整整一年记录的一些思考、参考信息和资料</li><li>架构文档：重新整理的系统性的技术文档，大概10多万字</li><li>白皮书</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="开源信息">开源信息<a href="#开源信息" class="hash-link" aria-label="Direct link to 开源信息" title="Direct link to 开源信息">​</a></h3><p>活动结束后将会上传代码，仓库地址：</p><p><a href="https://github.com/Cogine/RealityWorld" target="_blank" rel="noopener noreferrer">https://github.com/Cogine/RealityWorld</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="开源社区群">开源社区群<a href="#开源社区群" class="hash-link" aria-label="Direct link to 开源社区群" title="Direct link to 开源社区群">​</a></h3><p>由于人数问题以及广告太多，请先加我微信再社区群：ARealityWorld</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="活动信息">活动信息<a href="#活动信息" class="hash-link" aria-label="Direct link to 活动信息" title="Direct link to 活动信息">​</a></h2><p><strong>时间</strong>：2023.10.22</p><p><strong>地点：</strong>上海市长宁区长宁路1189号  长宁来福士办公楼T2座26楼 亚马逊演播厅</p><table><thead><tr><th align="left">时间</th><th>内容</th></tr></thead><tbody><tr><td align="left">13: 20</td><td>签到</td></tr><tr><td align="left">14: 00</td><td>技术分享</td></tr><tr><td align="left">17: 00</td><td>开放讨论</td></tr><tr><td align="left">18: 00</td><td>活动结束</td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_LWe7" id="联系我">联系我<a href="#联系我" class="hash-link" aria-label="Direct link to 联系我" title="Direct link to 联系我">​</a></h2><p>分享者：秦春林</p><p>Reality World 创始人，前华为河图核心成员，<a href="https://github.com/ElvisQin/thegibook" target="_blank" rel="noopener noreferrer">《全局光照技术》</a>《我所理解的Cocos2d-x》作者。</p><p>自去年从华为离职独自创业探索一年半，致力于思考和探索能够为用户体验和生活带来全新价值的软件构造方法，现将这一年的探索毫无保留开源给社区，我将用3个小时非常系统、全面地分享我所有的思考和技术理解。</p><p>欢迎各位朋友与我交流和讨论，我的微信：ARealityWorld。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="官网地址">官网地址<a href="#官网地址" class="hash-link" aria-label="Direct link to 官网地址" title="Direct link to 官网地址">​</a></h2><p><a href="https://realityworld.com/" target="_blank" rel="noopener noreferrer">https://realityworld.com/</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="报名地址">报名地址<a href="#报名地址" class="hash-link" aria-label="Direct link to 报名地址" title="Direct link to 报名地址">​</a></h2><p><a href="https://9371398676573.huodongxing.com/event/1723877940100" target="_blank" rel="noopener noreferrer">https://9371398676573.huodongxing.com/event/1723877940100</a></p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/reality-world">Reality World</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/open-source">Open source</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Citation"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/conversational-computing">Conversational computing: a new programming model empower LLM applications</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-04T00:00:00.000Z" itemprop="datePublished">October 4, 2023</time> · <!-- -->One min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/ElvisQin" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/ElvisQin.png" alt="Chunlin Qin" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/ElvisQin" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Chunlin Qin</span></a></div><small class="avatar__subtitle" itemprop="description">Creator of Reality World</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="citation">Citation<a href="#citation" class="hash-link" aria-label="Direct link to Citation" title="Direct link to Citation">​</a></h2><p>Cited as:</p><blockquote><p>Qin, Chunlin. (Oct 2023). Conversational computing: a new programming model empower LLM applications. Reality World. <a href="https://realityworld.com/blog/conversational-computing" target="_blank" rel="noopener noreferrer">https://realityworld.com/blog/conversational-computing</a>.</p></blockquote><p>Or</p><div class="language-latex codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-latex codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">@article{qin2023conversational,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  title   = &quot;Conversational computing: a new programming model empower LLM applications&quot;,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  author  = &quot;Qin, Chunlin&quot;,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  journal = &quot;Reality World&quot;,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  year    = &quot;2023&quot;,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  month   = &quot;Oct&quot;,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  url     = &quot;https://realityworld.com/blog/conversational-computing&quot;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a href="#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References">​</a></h2></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/reality-world">Reality World</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/cogine">Cogine</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="经过整整一年的研究、学习、思考、设计与开发，终于完成了Reality Create v0.1.0版本的开发，它实现了Reality World整个计划中最核心的运行时原型，也同时验证了我这一年对未来数字世界和软件构造的思考和探索的最核心部分。"><link itemprop="image" href="https://realityworld.com/img/blog/2.jpg"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/thinking">对未来数字世界和软件构造的思考</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2021-08-26T00:00:00.000Z" itemprop="datePublished">August 26, 2021</time> · <!-- -->80 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/ElvisQin" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/ElvisQin.png" alt="Chunlin Qin" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/ElvisQin" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Chunlin Qin</span></a></div><small class="avatar__subtitle" itemprop="description">Creator of Reality World</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="/assets/images/2-ea7a0b77be7f3ea877430d34be6a9c33.jpg" width="3360" height="2100" class="img_ev3q"></p><p>经过整整一年的研究、学习、思考、设计与开发，终于完成了Reality Create v0.1.0版本的开发，它实现了Reality World整个计划中最核心的运行时原型，也同时验证了我这一年对未来数字世界和软件构造的思考和探索的最核心部分。</p><p>可能有一些朋友关注过我这一年一直在折腾的Reality World创业的事情，然而很遗憾的是一直没有分享太多关于它的信息。一来是因为它所涉及的技术有比较多的创新尝试，在还没有真正的技术开发实践之前容易引起比较多的争议；二来是因为去年得到了一些大资本极大的兴趣，因此我想着一鼓作气等拿到投资之后再公布一些信息。当然因为各种原因到现在也还没有谈定投资，所以近几个月我就将全部精力用于开发了。经过几个月的艰苦奋战，今天终于有机会可以给大家分享一些我的想法，以及这一年的探索过程。当然Reality World还处于非常早期和原型的阶段，我预计还会再迭代几个版本到v0.5.0左右才会开始正式公布或者内测，所以这里我也不会涉及太多技术细节，但是我可以分享我们想解决什么问题，以及为什么要解决这些问题，并大概说明一些思路，这样大家应该能够初步了解Reality World是什么，同时我觉得，对这些问题的思考其实是非常有价值的部分。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="reality-world不是什么">Reality World不是什么？<a href="#reality-world不是什么" class="hash-link" aria-label="Direct link to Reality World不是什么？" title="Direct link to Reality World不是什么？">​</a></h2><p>由于我过去的工作经验和背景，以及Reality Create也包含的3D支持，在我与投资人或者其他朋友交流的过程中，大家普遍的印象是这是一个新的游戏引擎，所以大家的思路就是你跟Unity，Unreal Engine以及甚至包括国内近几年也有很多游戏引擎创业的一些区别或者说竞争关系，而会忽视我们技术上反而是更加核心和创新的部分，所以这个误区的澄清非常重要：</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="reality-create的核心不是一个游戏引擎">Reality Create的核心不是一个游戏引擎！<a href="#reality-create的核心不是一个游戏引擎" class="hash-link" aria-label="Direct link to Reality Create的核心不是一个游戏引擎！" title="Direct link to Reality Create的核心不是一个游戏引擎！">​</a></h3><p>虽然我本人多年的工作经验和背景都是与游戏引擎和渲染相关，同时现代游戏引擎工业的技术也在不断发展，但是我一直觉得制约用户随心所欲表达内容和逻辑的部分主要还是编程语言及其程序运行的机制，而游戏引擎架构和流程本身虽然也很复杂，但这部分都是相对比较确定的，例如除了编程部分，一些美术甚至策划也是能够比较好的使用引擎的一些相关功能，但是与之相反的是，逻辑的表达和编程通常还是需要专门的程序员。虽然一些特定类型的游戏系统可以通过数据驱动或者配置的形式部分实现非程序员的逻辑组织，但这样的架构还是很难做到通用，显然数字世界还有着非常多的各式各样的需求，这些需求需要一些通用的逻辑表达能力。</p><p>所以Reality World的核心是一套运行时，可以部分理解为一个虚拟机，但是与传统单纯解释源代码的编程语言的虚拟机相比，它包含一些源代码解释翻译之外的功能，例如权限验证、沙盒安全与互操作、分布式内容分发与同步、组件的依赖管理和动态加载等等，因此可以理解为Reality World是一个像区块链类似的分布式系统；同时，即使是在源代码的翻译解释部分，Reality World也有着很多区别于传统动态语言虚拟机解释的流程和架构。</p><p>基于这套运行时环境，我们会构建3D引擎的能力以使用户可以开发3D应用程序，但这部分技术跟传统的游戏引擎使用的技术不会有太大差异，当然因为运行时环境不同，与之相关的3D引擎的架构和流程肯定会有一些变化，所以我预期将来Reality Create的流程应该是可以有一些不同的创新体验的。</p><p>除了3D渲染，Reality Create的计划也可以开发2D应用程序，所以我们是用一种统一的编程语言和运行时环境，来统一3D和传统2D应用程序的开发。所以它确切的定位应该是一个基于分布式的、通用的应用构造和开发平台，而不单纯是一个游戏引擎。</p><p>与之相关的是，</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="reality-world当然也不是元宇宙项目">Reality World当然也不是元宇宙项目<a href="#reality-world当然也不是元宇宙项目" class="hash-link" aria-label="Direct link to Reality World当然也不是元宇宙项目" title="Direct link to Reality World当然也不是元宇宙项目">​</a></h3><p>不管怎么定义，至少目前的元宇宙大部分都是偏向于3D，然后期望人们有些更多沉浸式的虚拟生活。这在某种程度上说跟Reality World的理念甚至是相反的，从名字就可以看出，我选择Reality这个词，是希望我们能够引导用户更多关注现实，Reality World的目标是希望通过提供更简化、更具互操作性的一些编程体验，使更多的人能够随心所欲地表达TA对现实世界的理解，并将这些理解转化为可交互的数字的形式，与其他更多人分享，我觉得应用的开发和构造与文字、图片、视频以及其他信息载体一样，最大的价值仍然是表达人类大脑中最深刻的思考、智慧和逻辑。</p><p>实际上，我心里面对Reality World的最精准的描述是：</p><p><strong>A self-evolving interoperable system.</strong></p><p>或者：</p><p><strong>Interoperating with multi-applications in a modular and composable system.</strong></p><p>也许看了后面的一些介绍你能够大概理解上面两句话的含义</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="构建一个互操作的数字世界">构建一个互操作的数字世界<a href="#构建一个互操作的数字世界" class="hash-link" aria-label="Direct link to 构建一个互操作的数字世界" title="Direct link to 构建一个互操作的数字世界">​</a></h2><p><img loading="lazy" alt="img" src="/assets/images/3-2935ce82c46c3780bb9a6be5605f32ff.jpg" width="3356" height="2096" class="img_ev3q"></p><p>互操作是Reality World最核心的机制</p><p>我印象中，工业界和媒体开始真正讨论互操作性及其相关的一些论据，大部分都来源于Tim Sweeney的那篇演讲：<a href="https://link.zhihu.com/?target=https%3A//dl.acm.org/doi/10.1145/3306307.3339844" target="_blank" rel="noopener noreferrer">https://dl.acm.org/doi/10.1145/3306307.3339844</a></p><p>在某种程度上说，Reality World的目标跟Tim的一些描述和愿景是相似的，但也存在比较大的根本不同，我首先描述跟Tim演讲的一些关系和逻辑，然后再介绍我们的思考，通过这些问题就可以比较自然地理解Reality World的目标以及想解决的问题。</p><p>实际上我第一次看到这篇演讲是在去年7月左右，那个时候我的基本架构的构思已经初步完成，尤其是最核心也是最重要的一步基础已经设计好，当时看到这篇演讲感到很多共鸣，也是对自己的一种很大的激励，毕竟有对技术和行业都有非常经验和影响力的大佬也有类似的思考和行动。但从去年到现在，我们还是沿着我们早先的技术思路，基本上并没有去关注和参考太多Epic的东西，实际上我们从技术方案到目标都是有很多不同。</p><p>在技术层面，Tim认为这样的目标大概可能需要10年才能完成，但Epic会朝着这个目标逐步逼近。Epic的路线大概是几步：首先将一些偏社交或者玩家的非专业游戏开发者转移到《堡垒之夜》中，这部分开发者都在《堡垒之夜》的游戏内部而不是单独使用Unreal Engine去创作，这个模式其实类似Roblox的模式，它也是一种游戏引擎这种商业模式的转型：传统的游戏引擎只是一个单机的生成应用程序的软件，开发者开发的内容由自己去分发和运营，这样游戏引擎仅作为一个工具，它只参与程序的开发，而无法参与分发和运营，因此无法形成生态，所以尽管一些引擎有庞大的开发者数量和群体，但是这种数量并没有很有效的方式可以转化为生态。然而Roblox和《堡垒之夜》是一个分布式系统，你的内容必须分发到这个分布式系统中并由特定的客户端运行时环境来运行，而无法像单独的游戏引擎那样自行分发和运营，这样Roblox和《堡垒之夜》就可以参与整个内容的全部生命周期，这样就形成生态，其他的服务都可以通过这套分布式系统进行提供，而对用户的好处也是简化了内容的分发部署，以及更多便捷的集成服务，例如与其他玩家的互动。</p><p><img loading="lazy" alt="img" src="/assets/images/island-ed77d6189ea90804947341de732b2a5f.png" width="1932" height="1162" class="img_ev3q"></p><p>《堡垒之夜》Creative模式</p><p>为了要使用户在《堡垒之夜》中进行内容开发，就带来了两个问题：一是编程语言的问题，二是互操作性的问题。要在《堡垒之夜》中运行一个第三方开发者未受信任的代码，这是一个非常难的问题，这也涉及到Reality World要解决的第一个核心问题。</p><p>现在整个编程语言以及编译的体系架构，都是基于一个假设，即整个应用程序的所有源代码都被编译为一个单一的应用程序，这也即是编译和构造一个应用程序的主体可以认为是只有一个主体，即开发者，不管你背后是一个大团队或者大公司，最终编译发布应用程序的是一个特定的个人、部门或者组织。这样说有什么意思，这就意味着，整个应用程序的安全性由这个单独的主体负责，你需要解决软件的bug，检查所有可能的安全漏洞等等，保证软件最终运行是可靠的。而对于编程语言来讲，它不对软件的安全做任何假设：理论上，只要你拥有源代码，你就可以几乎访问整个应用程序内存中的数据，所以你必须确保你程序中的所有逻辑行为是正常的。如果所有代码都是由你自己公司的程序员编写的，这当然是天经地义的事情，如果你使用了第三方的开源代码或者闭源的二进制库，你必须由你自己去确保这些第三方的代码不会破坏你的软件运行。</p><p>这样天生就将每一个软件当作一个封闭、独立的环境，操作系统的内存分配和管理系统保证你的内存不会被其他进程的程序非法访问，这样软件就可以安全地运行，当然即使如此，你的程序当中涉及对外部数据读取的部分仍然可能导致内存安全问题。然而这种隔离是与我们现实世界的运行方式完全相反的，现实世界整个体系是基于协作和分工来实现文明发展的，计算机本来具有更强大的逻辑体系，然而实际上我们并没有在软件世界建立起比较简单地分工与协作机制。</p><p>现代软件变得越来越复杂，这种复杂的体系结构本来就希望能够借助更多的协作与分工的精神和思想来实现更大的复杂度和功能，这种协作的第一个要求是让未受信任的第三方代码可以在你的内存环境中执行代码。这也是《堡垒之夜》面临的第一个问题。按照现代编程语言的一些思路，一个源代码能够在一个内存环境中被执行，那表示其对应的主体知道和负责其中的安全问题，编程语言本身没有太多机制来解决这个问题。这又分为两种情况：静态语言和动态解释性脚本语言。对于动态而言而言，如lua，它们通常不能直接访问内存，开发者所能操作的都是封装在一定类型和对象中，现代大多数编程语言都按照类型进行寻址，也即是类型系统本身基本上可以保证程序的安全，如果你的源代码不知道一个对象的地址，你就不可能访问到它。然而实际现在大多数编程语言都提供静态变量或者全局常量之类的方式，这种方式使得内存环境中的其他代码可以获取到这些共享信息，从而对软件进行破坏。为了避免这种问题，Roblox就对Lua进行了改造，叫做Luau，比如通过禁止全局变量，以及禁止一些能够访问全局变量的库函数等等机制来实现一种沙盒安全，这样第三方开发者开发的代码就可以放心地在Roblox app中运行。</p><p><img loading="lazy" alt="img" src="/assets/images/luau-8dcd3e07aca728930025b827afc3d0d9.png" width="1446" height="486" class="img_ev3q"></p><p>如果第三方未受信任代码是二进制的机器码，这个问题就更严重了，因为机器码是可以访问内存地址和寄存器的，那可以造成的破坏是无法想象的。然而人们仍然希望能够实现类似分工协作的方式，这方面最具有代表性的例子就是浏览器，浏览器是一个非常复杂的软件，现代浏览器往往都可以支持第三方二进制的插件，来提供一些更高性能的增强功能，例如浏览器的字体渲染往往都是使用第三方字体渲染库。为了解决这种由于未受信任二进制代码导致的安全问题，人们提出一些软件隔离（software-based fault isolation，SFI）技术，相对应操作系统或硬件的内存隔离，SFI是用于构建包含未信任组件的安全系统的一种轻量级方法，能够用于减少由于内存安全bug导致的攻击，SFI通过严格将第三方未信任软件限制在自己的沙盒内存区域，来隔离这种内存安全导致的破坏。用例包括浏览器使用SFI来扩展第三方组件，例如经典的Native Client SFI syetem（NaCI）使用SFI来扩展第三方c库，使得浏览器可以使用如第三方的字体，音频，XML解析等库；在边缘计算节点与第三方未信任客户环境进行联合计算等等。</p><p>NaCI存在较大的运行时性能，因为它的机制一般对第三方代码不做太多要求，假设其按照一般的方法进行开发，然后仅仅在调用这些方法的时候为其分配独立的内存区域进行隔离，它基本上是用软件模拟操作系统的内存隔离机制，比如每次切换都需要保存大量的状态和寄存器地址等等。为了减少这种隔离导致的代价，Web Assembly就使用另一个思路，由于Web Assembly程序都会编译为Wasm文件，由Wasm虚拟机解释执行，而不是底层的二进制代码，所以Web Assembly有机会对程序进行一定的分析，通过基于Control-Flow Integrity (CFI)技术，Web Assembly的编译器可以检查出程序中哪些代码可能会对这种沙盒环境造成破坏，从而禁止这样的代码生成合法的Wasm程序，因此也就实现了沙盒安全。但是由于这种检查是在编译期，并对第三方程序的构造过程有一定的要求，因此在实际执行的时候就可以避免在这种隔离安全的保护机制上花费过多的开销。</p><p>Web Assembly之所以是一种未来非常有潜力的技术，不仅仅得益于对Web的友好，接近机器码的字节码，多语言支持等等，这种沙盒技术也是很大的一个技术点。在Web Assembly之前还没有一种技术可以很好地普及和运用沙盒技术，例如JVM上有一些方案，但大多有些性能问题，或者不能完全保证安全，或者方案比较重。Web Assembly这种优秀的沙盒技术使得沙盒模式在以后的软件构造中可能被大规模使用，也就会实现更多的软件协作与分工，事实上比如现在对未受信任多应用环境要求比较高的环境如区块链就大多转型Web Assembly，而如Docker和Severless这种对虚拟环境要求比较高的环境也在逐步转向Web Assembly。</p><p><img loading="lazy" alt="img" src="/assets/images/verse-3604fc0feca3a40971cf71a64a6a61b6.png" width="1920" height="1079" class="img_ev3q"></p><p>Epic推出Verse language</p><p>回到《堡垒之夜》，Epic显然不可能让玩家使用Unreal Engine的C++或者blueprint开发的应用程序在《堡垒之夜》内存环境中运行，Unreal Engine目前也没有比较成熟的脚本编程语言方案，因此Epic需要开发一套新的脚本语言，这就是今年早些时候发布的Verse programming language。Epic为此挖来了Haskell的作者Simon Peyton Jones，以及之前收购的一个为Unreal Engine开发脚本语言的团队SkookumScript，据说还有写V8内核的作者。</p><p>关于Verse language本身，目前还没有太多信息，但是可以想象这个脚本语言的使命一是为《堡垒之夜》的创作提供一种安全的编程语言，而且可以想象这个脚本语言必然包含一定的沙盒机制，来保证安全性。</p><p>协作的第二个要求是互操作，互操作性的定义如下：</p><blockquote><p><strong>Interoperability</strong> is a characteristic of a product or system to work with other products or systems</p></blockquote><p>互操作通常是和标准相关的：</p><blockquote><p>If two or more systems use commondata formatsandcommunication protocolsand are capable of communicating with each other, they exhibit<em>syntactic interoperability</em>. XML and SQL are examples of common data formats and protocols.</p></blockquote><p>互操作和软件隔离通常是相互矛盾的，互操作表现为我希望更简单更方便地访问别人的数据或接口，而隔离则假设除我之外的代码都是不可信的，不要轻易地访问，或者系统会提供一些机制使这种访问的代价和难度增加。尤其在游戏这种实时的运行环境，这种代价和难度往往意味着性能问题。</p><p>Tim在2019年的演讲中大量提到了标准，为了实现多个独立应用程序之间的协作，那么必然要建立大量的标准，有了这些标准，互操作就变得简单，例如《堡垒之夜》现在的Creative模式实际上已经有了很多标准，比如一个物体怎么摆放在环境中，并可以被其他玩家交互，这都是可以由Device来定义的，这实际上就是一种形式的标准或者接口，后续基于Verse的代码只要遵循这些标准，则可以很轻易的与其他的环境进行交互。</p><p>对这两个问题，Reality World都有着不同的技术思考和方案。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="更轻量级的隔离技术">更轻量级的隔离技术<a href="#更轻量级的隔离技术" class="hash-link" aria-label="Direct link to 更轻量级的隔离技术" title="Direct link to 更轻量级的隔离技术">​</a></h3><p>尽管Web Assembly的隔离技术非常优异，但是它并没有改变程序本身的构造方式，即如果你的代码本身就不含破坏别人的恶意代码，那么其实你的开发过程与过去的方式并没有什么区别。而Reality World希望简化编程的开发，如本文后面编程方面的内容，我们还希望对编程的体系做出一些调整。因此我们会把各种问题放到一起考虑，而不是单纯一个一个地解决问题。例如软件的可组合性、模块化、编程复杂度的降低、互操作等等。</p><p>如后面的内容所知，我们还对应用程序的构造方法进行了调整，而不是仅仅把程序当作一个黑盒子来进行统一的隔离，例如传统的隔离技术大都是基于比较底层的编译惯例，如方法调用（Calling Convention）来设计隔离机制，这样使得不需要对用户的开发过程造成太大的影响。在Reality Create中，我们的每个组件的很多行为和构造过程是由运行时自动推导进行的，因此我们本身已经对用户的开发过程有一定的影响，这同时也意味着我们对程序的结构有着更多信息，因此我们可以在更上层的地方实现一些隔离机制，同时由于上层的机构包含对程序的更多的信息，因此会带来一些新的灵活性和能力。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="互操作性的本质是应用碎片化的问题">互操作性的本质是应用碎片化的问题<a href="#互操作性的本质是应用碎片化的问题" class="hash-link" aria-label="Direct link to 互操作性的本质是应用碎片化的问题" title="Direct link to 互操作性的本质是应用碎片化的问题">​</a></h3><p>互操作性这个概念，我跟大部分投资人解释基本上都是很难理解的，当然这里可能我对互操作性赋予了更多的意义。从程序机制上来讲，互操作性主要涉及两个独立的程序之间进行相互调用的能力，比如大部分语言都可以通过C接口实现相互调用，再往上一点，任何程序之间传递字符串然后内部进行格式解释，也仍然是能够进行通信的。实际上互联网的机制就是如此，OSI（Open systems Interconnection）的机制就是实现了任何计算机或者任意程序之间的字符串通信，从而解决了整个计算机网络互联的问题。</p><p>传统的软件世界通过一些标准来建立互操作的基础，例如HTML、XML、SQL、USD等等，比如Nvidia就基于USD构建了Omniverse，由于其对USD格式的良好支持，使得其可以兼容大部分的内容制作工具，就构建起一个以Omniverse为中心的内容和应用生态。</p><p>然而这种基于文本标准的方式仍然有一些缺陷，例如其数量是非常少的，通常必须等一个组织对一个标准有一定影响力之后才能形成实时上的标准，被更多的三方兼容和支持。想想现实世界，各个实体之间的交互和联系几乎是无所不在的，例如一个人在路边新开了一家饭店，路过的人随时可以进去吃饭，不会说还要先接一下饭店定义的一个接口。而程序是必须有严格的逻辑的，比如保证地址、参数和接口的一致性才能进行互操作，这给软件世界的互操作带来了一定的困难。我们应用程序开发的流程通常都是先定义内部数据结构，实现软件功能之后，再以一定的形式封装一些接口，并以某种方式公布出来，由感兴趣的三方去集成。然而实际上有大量的软件开发者是没有精力或者能力去提供这些接口的。想象一个场景：开发者A开发了某个应用给用户新增了一种新的健康类的数据信息，这个数据本来是属于用户的，这个时候用户想要用这个数据来实现另一个事情，TA想自己或者说让其他开发者B帮助开发一个应用来使用这些数据，这种情况下通常是做不到的，因为开发者A可能并没有太多动力去提供这个接口，因为TA可能要耗费很大的精力，除非平台提供一些这种非常便利的机制使得TA可以很轻易地暴露出来。</p><p>因此，Reality World的其中一个重要机制，就是要让一个开发者开发的应用，其定义的数据接口非常轻易地被其他开发者开发的应用访问，同时结合上面的沙盒技术保证这种数据访问的安全，这也就是为什么我们的沙盒技术不能只是在最底层实现。</p><p>其实更深刻一点理解，互操作问题其实是一个软件碎片化的问题。传统的软件开发都是先开发内部数据结构和数据存储，然后在必要的时候再把API包装使用某种形式的标准包装成外部接口，这样就造成碎片化，因为即使是针对同样的一类逻辑和数据，不同的应用程序或服务往往会定义不同的数据结构或处理逻辑，这就形成API的碎片化，使得相互之间非常难以协作。试想你可以在两个应用之间协商修改各自的API接口及定义，这是一对一的关系，或者说像支付宝这种平台性质的接口也是容易定义，这是一对多的关系，一对多的关系发展显然是缓慢的，必须让这个“一”有机会且需要时间发展壮大。如果我们希望一种更加高效，更加丰富的协作机制，那么显然我们需要多对多机制，这里面就要求我们对软件开发流程做一些调整。</p><p><img loading="lazy" alt="img" src="/assets/images/usd-1109031da5c391a7ac8194a67e234d38.png" width="1954" height="864" class="img_ev3q"></p><p>Pixar USD</p><p>要想实现这种机制，其实现有的很多技术可以给予很多启示。我们先看USD格式，尽管从表面看USD跟其他的标准类似只是一种数据格式或协议，但实际上它远远不止如此，它还是一种非常易于扩展的格式，它提供了一种plugin的机制使得开发者可以对格式做很多定制和增强功能，并且可以通过一个Schema定义来生成自己定义格式的解析代码，然后通过Plugin来调用自定义的格式解析和代码。这就好比它帮助你编写了文本格式的编解码，尽管看起来不过如此，看起来只是一种模板化的代码生成机制，但是当这种解析代码能够与逻辑高度融为一体的时候，事情的本质发生了一些变化，试想使用USD你的流程是这样：首先针对一种特定数据自定义一个Schema，然后调用USD的API帮助我们生成相关的解析代码，如果这段解析代码能够以某种机制被其他开发者拿到，那么TA的程序就能够轻松解析我们的API。当然如果你修改了Schema，仍然需要对方进行同步，但是这种流程本质上改变了我们的思路：过去我们是先定义内部做法，再与外界沟通，这就容易带来一些复杂度和碎片化；现在是我们先想着自己就是基于一种标准在开发，然后需要的时候就能够很方便地暴露出去，这里USD充当了一种协调的机制并为这种协调的机制提供了一些辅助功能。苹果的usdz格式以及英伟达的MDL都是基于USD的这种扩展能力来实现自定义的资源格式。</p><p>API碎片化的第二个例子是LLVM，本质上LLVM在编译器领域的创新主要做的是模块化，早期的编译器开发，各个前端都要分别集成各个后端，编译器开发的复杂度非常高，这里面其实就是多对多的问题，看似很简单，每个前端与每个后端分别调一调，但随之代码的管理和维护成本是很高的，有时候某些内部设计不一致就会导致大量的重复，这就是碎片化问题。由内而外的设计总是不可避免会导致碎片化，碎片化带来软件复杂度，管理和研发成本。当LLVM提供了一个统一的低层IR表述之后，编译器的复杂度大大降低，比如现在能够很轻易地开发一些DSL语言，因为你完全不需要操心后端，只需要把你的代码生成LLVM IR即可。</p><p>当然LLVM并没有提供类似USD那种生成格式的机制，那是因为LLVM只有一种IR，所以写成一种固定的格式即可，过去的编译流程基本上都比较简单、固定。但是随着现代深度学习编译器的进展，由于深度学习有着相对比较特定的数据表述，各个公司内部都有开发一些特定的编译流程，它是比一般的LLVM IR更上层的抽象，所以我们对多层级IR表述又有了需求，于是在LLVM的基础上又发展出MLIR，它允许开发者社区能够自定义IR。然而与USD的Schema非常相似的地方是，MLIR为了避免碎片化，使不同开发者自定义的IR之间能够更轻易的协作，它也提供了一种类似的代码生成机制，在MLIR中称为Dialect ，例如如下的Dialect定义：</p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">def Toy_Dialect : Dialect {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let summary = &quot;Toy IR Dialect&quot;; let description = [{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    This is a much longer description of the</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Toy dialect.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // The namespace of our dialect.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let name = &quot;toy&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// The C++ namespace that the dialect class // definition resides in.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let cppNamespace = &quot;toy&quot;;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>生成的C++代码如下：</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">class</span><span class="token plain"> </span><span class="token class-name">ToyDialect</span><span class="token plain"> </span><span class="token operator">:</span><span class="token plain"> </span><span class="token base-clause keyword" style="color:rgb(189, 147, 249);font-style:italic">public</span><span class="token base-clause"> mlir</span><span class="token base-clause double-colon punctuation" style="color:rgb(248, 248, 242)">::</span><span class="token base-clause class-name">Dialect</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">public</span><span class="token operator">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token function" style="color:rgb(80, 250, 123)">ToyDialect</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">mlir</span><span class="token double-colon punctuation" style="color:rgb(248, 248, 242)">::</span><span class="token plain">MLIRContext </span><span class="token operator">*</span><span class="token plain">context</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token operator">:</span><span class="token plain"> mlir</span><span class="token double-colon punctuation" style="color:rgb(248, 248, 242)">::</span><span class="token function" style="color:rgb(80, 250, 123)">Dialect</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;toy&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> context</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      mlir</span><span class="token double-colon punctuation" style="color:rgb(248, 248, 242)">::</span><span class="token plain">TypeID</span><span class="token double-colon punctuation" style="color:rgb(248, 248, 242)">::</span><span class="token generic-function function" style="color:rgb(80, 250, 123)">get</span><span class="token generic-function generic class-name operator">&lt;</span><span class="token generic-function generic class-name">ToyDialect</span><span class="token generic-function generic class-name operator">&gt;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token function" style="color:rgb(80, 250, 123)">initialize</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">static</span><span class="token plain"> llvm</span><span class="token double-colon punctuation" style="color:rgb(248, 248, 242)">::</span><span class="token plain">StringRef </span><span class="token function" style="color:rgb(80, 250, 123)">getDialectNamespace</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;toy&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">initialize</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样多种IR就可以能够被轻易组合使用，你可以选择社区各种丰富的模块进行组合，来生成特定的编译流程，所以MLIR又称作“生成编译器的编译器”。实际上，碎片化在工业界是一个很大的问题，每家公司在开发自己的软件的时候不会考虑那么多，觉得我只要投入研发资源把自己软件做好就行，但是真正在用户侧使用的时候，TA可能需要多个软件是可以相互协作的，甚至你的用户可能就是开发者，这个开发者可能希望不同的软件可以被更高效的集成和管理。LLVM的作者Chris Lattner最新的创业公司Modular实际上核心就是解决这个问题，他的新编程语言Mojo，除了一些语法层面的传统一点的东西，很多核心能力都是来源于底层的MLIR，其中MLIR跟Mojo有更深度的整合，使得Mojo具有很强的元编程能力。Modular的最核心的逻辑其实跟当年的LLVM类似，解决碎片化问题，当然Modular有很多现在软件的运营思路可能会形成更好的平台和生态，因此它是一家商业公司，不仅仅是一个开源项目。</p><p><img loading="lazy" alt="img" src="/assets/images/modular-ec183275c9c4d2f77583a82e8119e52f.png" width="2157" height="1113" class="img_ev3q"></p><p>Modular</p><p>上述的软件架构都为解决应用之间互操作及其碎片化提供了很好的思想，然而为了更好的软件协作，这些机制还不够。上述的软件都是比较偏底层的基础软件，而不是面向上层用户侧的，因此不需要考虑很多其他问题，比如性能和格式的进化。当进入到一个更上层的消费端应用，首先上述的方式在不同的模块之间交换的都是文本数据，如果你让一个实时的游戏内部的每一次互操作都需要编解码文本，这显然是会影响性能的；此外，应用层的需求更容易变化，即使平台提供了一种生成统一格式解析的代码及其发现的机制，但是怎么应对这些格式的更频繁地变化呢？为此，Reality World在这些方面做出了一些创新尝试。</p><p>结合前面讨论的沙盒技术、互操作、碎片化等等机制，Reality World希望能够通过一些创新探索，构建起一个更好的互操作平台，使得上面的应用之间可以更好地协作，它看起来像是基于OSI之上添加的一个互操作层，在这个互操作层中，应用程序操作的是来自其他应用的内存数据，就像你访问自己的内存数据一样简单，尽管这个数据可能来自于其他的服务器。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="新的应用程序构造方法">新的应用程序构造方法<a href="#新的应用程序构造方法" class="hash-link" aria-label="Direct link to 新的应用程序构造方法" title="Direct link to 新的应用程序构造方法">​</a></h2><p><img loading="lazy" alt="img" src="/assets/images/pl-01db64776749f259941139b1e0b0fd19.jpg" width="3360" height="2100" class="img_ev3q"></p><p>Reality World对程序的构造过程做了很多调整</p><p>我们程序员，终其一生可能都希望能够更好地理解程序到底是怎么运行的，这种理解不光能够让我们更高效地编写更健壮的代码，从而创造软件的价值，同时，编程的机制本身充满着无穷的魅力，因为它可能是人类有史以来能够表达人类大脑中复杂的思维和逻辑的最好的机制之一，它将人类对物理世界的理解及其形成的智慧转化为为人类服务的工具和力量，这是我们热爱编程的其中一些原因。</p><p>十多年来，对于编程，我一直有两种不一样的情感：</p><ul><li>我一直不喜欢面向对象编程的方式</li><li>我更喜欢开发能够用于构造软件的软件</li></ul><p>今天，Reality World的第二个核心关注点和基础就是在这两个方面做出了一些新的探索。世界上只有大约不到0.5%的人是会编写代码的，约3000万左右，所以数字化表达的潜力还远远没有被发挥出来。如果我们将这个数字提升到5亿~10亿，看看还有哪些变革需要发生，可能与你想象中不太一样，编程语言的语法本身可能并不是制约因素。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="面向对象的本质是隔离">面向对象的本质是隔离<a href="#面向对象的本质是隔离" class="hash-link" aria-label="Direct link to 面向对象的本质是隔离" title="Direct link to 面向对象的本质是隔离">​</a></h3><p>十多年工作经历，我写过C#、C、C++、Ruby、Lua、Rust等，以及最近一年多，我几乎看了所有能买到跟编程语言和编译等相关的书籍（后面会介绍）。在我写过的代码中，总有一种感觉，不管我看过多少设计模式或者架构相关的资料，我总是觉得很难写出那种逻辑结构特别清晰的架构和代码，因此编程体验像是总有一个什么东西，堵在我的心里。</p><p>我们现代的项目开发使用的编程语言，或多或少大部分是和面向对象相关的，尽管看起来面向对象的本质是让我们更好地封装各自比较独立的逻辑，使大规模软件组织起来更加轻松：你不需要关心其他对象的内部逻辑就可以轻易地和它们一起组合起来协作。</p><p>然而实际上并不是这样，大部分面向对象编程语言会让人（特别是初学者）误以为编程就应该这样，它是在模拟真实世界的运行机制。那为什么这么完美的模型却没有产生这么完美的体验呢？直到最近一年多对面向对象的更多理解（特别是Erlang）才体会到其中一些问题。</p><p>知乎 </p><p><a href="https://www.zhihu.com/people/16d0cb25df98c0c909e60b135a5800c5" target="_blank" rel="noopener noreferrer">@大宽宽</a></p><p> 有一篇回答：<a href="https://www.zhihu.com/question/29888990/answer/703226836" target="_blank" rel="noopener noreferrer">如何看待Erlang之父Joe Armstrong觉得OO编程很烂？</a>，其中引用到Erlang之父Joe Armstrong的一段采访：<a href="https://link.zhihu.com/?target=https%3A//www.infoq.com/interviews/johnson-armstrong-oop/" target="_blank" rel="noopener noreferrer">Ralph Johnson, Joe Armstrong on the State of OOP</a></p><blockquote><p>Alan Kay himself wrote this famous thing and said <strong>&quot;The notion of object oriented programming is completely</strong> <a href="https://www.zhihu.com/search?q=misunderstood&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A703226836%7D" target="_blank" rel="noopener noreferrer">misunderstood</a><strong>. It&#x27;s not about objects and classes, it&#x27;s all about messages</strong>&quot;. He wrote that and he said that the initial <a href="https://www.zhihu.com/search?q=reaction&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A703226836%7D" target="_blank" rel="noopener noreferrer">reaction</a> to object oriented programming was to overemphasize the classes and methods and under emphasize the messages and if we talk much more about messages then it would be a lot nicer. The original Smalltalk was always talking about objects and you sent messages to them and they responded by sending messages back.</p></blockquote><p>Alan Kay认为OOP的核心是关于消息，但是这样说其实我个人觉得并不太好理解到本质，因为消息更像是OOP这种设计下的一种机制或结果，而不是OOP本身的定义。我觉得OOP的本质应该是隔离，只有做到真正的隔离，才能真正降低系统的复杂度，因为绝对的隔离使得你完全不需要也不能了解另一个物体内部的运作，你们只需要通过一些外在的属性进行交互，我们的开发也仅需要了解这些简单的外在属性。现代大部分编程语言更强调的是object和class，认为对象的核心是关于封装，这本身也没有错，封装的目的也一定是为了让别人不需要关注你的内部细节，但问题在于，很多面向对象编程语言忽略了隔离的意义，为了方便程序员更灵活直接地获取数据和方法，提供一些机制，使得一个对象可以很轻易地访问到另一个对象内部的、跟其内部运作相关的数据或方法，这些原本是需要绝对隔离的。这种设计就使得隔离失去了意义，尽管我们可以指定规范要求自己以对象为单位进行绝对隔离，但是大部分情况下，我们很难做到一个很好的设计，最后的结果是程序内部对象之间相互耦合太多，不管是管理、维护、理解起来都是花费很大的精力。</p><p><img loading="lazy" alt="img" src="/assets/images/Robert_Virding_and_Joe_Armstrong-82ddcf57cc160dd3b30ce80b0351bb6b.jpg" width="1155" height="697" class="img_ev3q"></p><p>Erlang之父Joe Armstrong（右）</p><p>Erlang就采用了一种不同的机制，它从语言体系上就不允许对象之间能够直接访问内部数据或方法，每个函数都分配为独立的线程，线程之间只能通过消息进行传递和联系，这样程序员就很难写出耦合比较深的代码，同时这种隔离对并行计算和分布式也带来了好处。所以Joe Armstrong说，根据Alan Kay的描述，Erlang可能是唯一真正面向对象的编程语言：</p><blockquote><p>Erlang has got all these things. It&#x27;s got isolation, it&#x27;s got polymorphism and it&#x27;s got pure messaging. From that point of view, we might say it&#x27;s the only object oriented language and perhaps I was a bit premature in saying that object oriented languages are about</p></blockquote><p>再回过来看面向对象的核心为什么是隔离，是因为真正的隔离机制才能保证避免耦合，才能降低软件复杂度，因为一个大型的软件系统有无数的对象，如果对象之间存在耦合的可能，那维护起来将是非常不容易的。而当你只提供了强隔离的机制，不让程序员能够很方便地获取另一个对象的引用，剩下的结果就是对象之间只能通过消息通信了，这就是Erlang的整个架构设计，这也是为什么Erlang是真正的面向对象编程语言。也因此，消息更像是隔离机制带来的结果。</p><p>就像现实世界一样，微观的每个原子内部都有自己特定的结构，原子之间相互作用形成分子，进一步形成宏观物体，宏观物体通过内部分子结构形成特定的外在属性，但是其他物体与之交互从来不需要了解其中的内部结构，这就是面向对象的美好世界，然而传统的面向对象编程模式则为了便利为一个对象访问另一个对象的内部结构开了一个口子，这个口子不仅破坏了面向对象的编程思想和精髓，也失去了其带来的好处。</p><p>尽管Erlang看起来是一种完美的架构，然而消息通信是一种操作起来不太便利的方式，比如为了进一步解耦它通常是传递字符串消息，字符串需要编解码，带来了性能问题；而另一方面消息编程模型通常是异步的，使得对逻辑的流程管理失去了控制力。Reality World在这两个方面都做了一些创新尝试，使得开发者既可以像传统的局部变量一样去方面其它对象的数据，又可以像Erlang一样拥有绝对的隔离，这种隔离带来编程复杂度上的减少，降低编程门槛。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="程序结构的复杂性">程序结构的复杂性<a href="#程序结构的复杂性" class="hash-link" aria-label="Direct link to 程序结构的复杂性" title="Direct link to 程序结构的复杂性">​</a></h3><p>对于编程语言本身而言，当前有很多Scratch编程平台，对于一个简单的任务：即只有少量输入和输出，且通常只有一个或少数几个函数的任务，大部分有一些基本逻辑和算术计算能力的人是可以在很短时间内学会的。这说明，单纯的逻辑计算并不复杂。</p><p>然而，真正的软件规模是非常大的，它往往是由众多的开发人员（这些开发人员甚至可能在地理位置上完全隔离）开发的几十甚至上百万行代码的组合，这种规模的软件程序显然不可能仅由简单的变量和函数构成，那样的话我们将很难管理错综交织、复杂的数据和函数引用。在《计算机程序的构造和解释》一书中指出，编程模型本质上要解决的是大规模软件构造的问题，不管是函数式编程还是面向对象编程模型。</p><p>为此，编程语言的设计者在数据和方法的基础上，添加了大量的抽象机制，例如类型、数据结构、继承、多态、重载、接口等等。这些机制的目标是要形成各种抽象，使得其他人员可以不需要关心一些实现细节，只需要关心与之交互的部分，即接口；当然除此之外，这种抽象也是帮助开发人员自身从逻辑上更好地管理自己所编写的众多代码。</p><p>然而正是这些为了帮助人们管理大规模软件构造的机制，提升了编程的门槛，例如非程序员肯定可以很快理解类和对象的概念，但是理解虚函数和多态就是另外一回事了。尽管这些机制的添加看起来是理所当然的，但是稍微深入理解一下编程语言的编译过程可以发现，这些机制通常是跟底层的编译机制相关的，而现代的编译流程又几乎是与底层的硬件架构有关的。例如继承的机制和限制，使得编译器可以计算正确的函数地址，例如你必须要从一堆复杂的代码中拿到一个对象的引用（这使得你不得不把多个代码文件交织在一起）才能正确地访问相应的方法，这使得程序几乎总是充满复杂的引用关系，尽管这看起来像是必须的，例如为了保证安全性，但某种程度上也是因为编译器必须要这样才能获得正确的对象地址，从而访问其中的数据和方法。但是如果仅仅是为了保证安全性，我们可以有很多机制，不是说我一定要每次亲自到一个店买到的东西才是绝对安全的，如果一个快递员本身是某种机制能够保证安全的，我就可以不用亲自去店里就可以获取到我想要的数据，这个时候我要关注的只是什么东西（数据类型），而不是实际物理地址（对象引用）。</p><p>从上面的分析，我们可以将程序的整个结构分为两个部分：其一是单个函数或者单个对象本身的相对比较简单的逻辑，其中可能仅仅涉及最基本的算术和逻辑计算；而另一部分则是为了帮助计算机编译系统（可能也是帮助程序员理解）构造大规模软件提供的一些信息。</p><p><img loading="lazy" alt="img" src="/assets/images/create-83a4808a18d663f143cd67c47dccbd84.png" width="2546" height="1427" class="img_ev3q"></p><p>Reality World在程序结构方面的目标，就是要提供一种系统架构，使得这种程序结构组织的复杂性被隐藏在编译系统和运行时内部，这样开发者就只需要关注最基本的逻辑和算术计算。我们通过提供一些额外的信息来使得运行时系统可以动态推导出一些构成大规模程序需要的结构。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="去中心化的数据管理">去中心化的数据管理<a href="#去中心化的数据管理" class="hash-link" aria-label="Direct link to 去中心化的数据管理" title="Direct link to 去中心化的数据管理">​</a></h3><p>除了编程语言语法和程序结构之外，还有一个通常容易忽略的问题，或者说因为目前编程的大部分都是专业程序员，这个问题看起来理所当然。那就是关于数据管理。数据管理是一个非常重要的问题，因为它既关乎程序的复杂度，又关乎前面提到的互操作性。</p><p>在应用开发中，开发者既需要编写逻辑代码，还需要处理数据管理：数据在什么时候初始化，在那个代码逻辑处初始化，从哪里获取数据进行初始化，对象被修改了怎样保存数据等等，甚至包括为了考虑缓存性能所做出的一些处理，这些工作是非常繁琐的。除此之外，开发者几乎总是还要关心存储，除非是仅存储在本地，否则还需要设置服务器存储和获取一些数据。这些工作对于普通的用户开发应用程序而言都是比较困难的事情。</p><p><img loading="lazy" alt="img" src="/assets/images/graphql-b82a89e1f03ad72a5c43b193911c69a7.png" width="1610" height="399" class="img_ev3q"></p><p>GrapQL</p><p>所以结合上述的程序结构化的自动管理，一种好的策略是程序的数据也可以自动管理，这样就使开发者仅关注一个个独立的基本逻辑和流程，所有涉及到或者说只是编译器或编译系统需要的管理都应该尽可能交给运行时。GraphQL在这方面做出了一些比较好的尝试，开发者只需要告知一个想要的数据类型，就可以很方便的获取到对应的数据，而将这些数据背后的复杂逻辑隐藏起来。</p><p>除了数据本身的管理，数据还涉及到互操作性的问题，用户希望自己一个应用的数据可以被其他应用方便地访问，这些机制都是和数据的管理过程及其设计息息相关的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="为ai而生的应用程序构造方法">为AI而生的应用程序构造方法<a href="#为ai而生的应用程序构造方法" class="hash-link" aria-label="Direct link to 为AI而生的应用程序构造方法" title="Direct link to 为AI而生的应用程序构造方法">​</a></h2><p><img loading="lazy" alt="img" src="/assets/images/5-25bf33bec4ab499cbb1f75fe4af6dc4e.jpg" width="3360" height="2100" class="img_ev3q"></p><p>Reality World的程序结构与文本合成是类似的</p><p>ChatGPT席卷了整个世界，或者至少是科技圈，不管是从资本，国企，民企，程序员个人等等都是受到很大的影响，当然也有像我们小孩的妈妈，以及他妈妈的朋友，目前还不太了解ChatGPT是干什么的。</p><p>我于2022年4.30日从华为离职并开始研究和设计Reality World的架构，那个时候的热点还是元宇宙。那个时候，由于没有现在大模型的这种能力，我们当然也没有主要去思考AI方面的，但是从我们自己的设计思路上，我和我们公司的2号员工，在2020年的时候就思考和讨论将来怎样让AI写代码，当然我们说的不是现在这种基于大模型来生成文本的方式生成代码。</p><p>但大模型确实加速了我们的一些想法。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="软件复用与可组合性">软件复用与可组合性<a href="#软件复用与可组合性" class="hash-link" aria-label="Direct link to 软件复用与可组合性" title="Direct link to 软件复用与可组合性">​</a></h3><p>我们起初的目标是让普通人可以编写代码并构造一个完整的应用程序。这也是我们前面第3部分讨论的内容。然而比较巧合和惊讶的是，至少从我们的设计思路上看：<strong>让普通人会编写代码与让AI编写代码的逻辑是类似的。</strong></p><p>逻辑和流程，本质上都是可以用语言表述的，因此我们人类的任何信息与智慧，当然也可以使用自然语言进行描述。然而语言文字是一种面向人类的信息载体，它是为了便于人类之间进行信息交流而设计的，所以它可能不那么严谨，甚至没有太多结构性，人们之间需要信息编解码，编解码的效率和能力可能差异都非常巨大。而程序，则是在自然语言基础之上加入更多的结构性，它在表述和记载逻辑的同时，可以直接与计算机和其他程序进行沟通，这就使得人类大脑中的逻辑不光可以用于人与人之间的信息交流，还可以更直接地转化为生产力。</p><p>然而要让AI能够生成代码，这件事情肯定是非常复杂的，当然由于ChatGPT的出现相信现在大部分程序员都能够感受到AI的代码生成能力，有些人比较坚信AI能够代替程序员生成程序，有些人则悲观一些，至少在短期内。</p><p>这里暂且不争论AI到底能不能或者什么时候替代程序员，我们回到问题本身。传统的文本合成，计算的是文字与文字之间，句子与句子之间的组合概率，这里有两个事情值得注意：第一是任何字之间都可以组合，所以ChatGPT总是可以给我们答案，哪怕其中的句子组合和逻辑是完全错误的；第二是一般常用于表述正确语法和语义的哪些文字信息是非常多的，也就是说ChatGPT理解我们一般的比较大众化的语义是很容易做到的。</p><p>计算机程序在这两个层面都与一般的文本知识信息不同：首先两段代码是不能简单合成的，两个代码之间在单纯地像两段文字放在一起之外，还需要处理参数的数量，参数的名称，类型，变量从哪里获取，API从哪里获取等等，这远远超出简单文字合成的范围。你可以合成一个文本组合的源代码结果，但是其中的逻辑可能完全是错误的，函数是不存在的，参数是错误的。因此目前来讲，大部分AI还是用于辅助比较局部、独立的代码生成，检查，提示等等，距离构造复杂一点的逻辑显然还缺乏一些基础。当然这并不妨碍它现在就可以作为一个不错的助手。</p><p>我们在Reality World的设计过程中，为了要让普遍用户可以构造程序，将程序的整个构造过程做了多处调整，从类型定义，数据初始化和管理，互操作性，程序结构的推演，线程隔离等等。其中还有一个重要的方面就是组合性，这种组合性使得两个相关的组件，不需要用户手动添加任何参数或者输入输出的设置，就可以正确地构造程序，例如如下的这段复杂的逻辑，整个Graph的节点是不需要用户连接的，全部是自动生成。</p><p><img loading="lazy" alt="img" src="/assets/images/4-c18cbdad8df763f282adf9e615337ed8.jpg" width="3356" height="2096" class="img_ev3q"></p><p>整个程序的连接关系是自动推导的</p><p>这样的组合性看起来是不可思议的，这里我不会讨论具体的实现方式，但是可以这样想象一下：编译器对于一个程序的所有源代码，本来就是首先当成一个个独立的模块进行编译的，只不过编译器除了编译每个指令本身，还使用一些符号表记载了所有外部模块引用的关系和地址，然后在链接阶段将这些地址修改为最终的绝对地址。从这里可以看到，程序的结构是有可能以更底层的方式去完成，而不是把这部分交给程序员。</p><p>这样的组合能力，使得程序的构造过程变成了单纯的合成，没错，这个合成的方式跟文本合成是非常相似的：它们仅仅是放到一起，不需要指定额外的程序结构信息，例如参数，变量，函数地址等等。这样我们就有机会让AI去生成程序，这里AI只需要从一般的文字意义上去理解组件的语义，并给出组件合成序列，而底层的运行时引擎将这些序列转化为真正的程序。</p><p>与直接ChatGPT构造程序代码不同的是，这里的代码一旦被构造，就是正确的，可以运行的，而不需要人去检查其中可能存在的程序逻辑的错误。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="面向ai的编程系统">面向AI的编程系统<a href="#面向ai的编程系统" class="hash-link" aria-label="Direct link to 面向AI的编程系统" title="Direct link to 面向AI的编程系统">​</a></h3><p>显然，与直接让AI构造复杂的程序逻辑相比，更好的使用方式可能是AutoGPT或者OpenAI的插件系统，在这种架构中，AI更多是负责比较通用的一些语义理解，然后把具体的一些与领域系统的交互交给专门的插件去解决。</p><p>然而在OpenAI的Plugin系统中，每个Plugin是一个特定的应用，尽管这种描述好的调用逻辑使得ChatGPT可以正确地调用各个应用软件的接口，但如果你的使用本身是要在多个plugin之间建立一些比较复杂的逻辑和流程，或者说我们想构造任意的应用程序，把每个plugin接口当作组件，这就又会回到让AI编写逻辑代码的问题。</p><p>相对于这种Plugin系统，Reality World提供的不是一个单个plugin，而是一种通用编程能力，它可以理解为是一种面向AI的编程系统，因为AI发出的文本序列，会被Reality World当作输入，然后按照程序构造的逻辑去检索相应的组件并组合构造，这样的程序要么是构造不出来的，要么就是至少能够成功运行的，而剩下的正确性问题就取决于组件描述的准确性和AI对语义的理解了。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="拥抱rust">拥抱Rust<a href="#拥抱rust" class="hash-link" aria-label="Direct link to 拥抱Rust" title="Direct link to 拥抱Rust">​</a></h2><p>我原本以为的开发周期还是会比较长的，毕竟设计的系统设计还是非常复杂的。早先我使用的是C++/C进行开发，进行了一些简单的语言包装和编译流程定制。因为我们2号员工一直是Rust爱好者，一直在鼓动我使用Rust，虽然之前看过Rust的一些介绍，但是感觉还是没有特别的动力去完全切换到Rust。</p><p>后来因为某些原因最终还是选择使用Rust进行开发，开始也是有些不习惯，但是在逐步学习和使用过程中感受到了Rust的好处，这里给大家分享和推荐一下。</p><p>Rust对我而言最大的好处和体验是，迭代速度比较快，这符合我现在的需求。只要代码编译通过，几乎不会花时间去排查一些比较诡异，甚至需要小心翼翼地断步调试才能发现问题的bug，一般有bug就基本上大部分还是逻辑问题，而且Rust编译器可以比较精准地告诉你问题的位置，基本上一看提示就知道该怎么改代码了。</p><p>当然缺点主要是大家讨论比较多的限制了，你得很小心翼翼地设计整个程序的架构，如果像传统C++那样到处是相互引用显然几乎肯定是你完全没法通过编译器，你得设计好整个程序对象的结构，这里推荐Bevy引擎就是非常好的架构，这样的架构几乎能解决大部分相互引用的问题。</p><p>第二个比较大的问题是多次引用和借用的问题了，这个问题相对好解决一点，首先架构好会少掉很多这种问题；其次对于局部的一些方法，实在是不可避免的，万能大法就是复制数据就好，这个也不需要完全回避，毕竟在C++中也经常会存在对象复制；再有稍微复杂一点就是使用move，先将数据move出来，然后进行操作之后再填回去，如果你能保证没有并发问题，这种思路也是一种方法。</p><p>最后，关于有些人会觉得，像Rust这样强迫开发者过早关注架构会影响快速迭代。这一点我不是很赞同，因为任何一个项目，快速迭代也是要正确运行的，而且如果项目本身思考着足够多，或者项目最终肯定是要上线使用的，我觉得慢一点一边迭代一边就把代码架构写的更好，也许最终是一件更好的事情。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="我这一年的创作过程">我这一年的创作过程<a href="#我这一年的创作过程" class="hash-link" aria-label="Direct link to 我这一年的创作过程" title="Direct link to 我这一年的创作过程">​</a></h2><p>我从2022年4.30日从华为离职，几乎整整一年时间全部都在思考整个系统的设计，以及后期的开发。刚开始2个月，思路还不是特别清晰，只是在不停、疯狂地看书，我几乎把所有能买到的中文跟编程语言和编译相关的书都看了一面。当然我不会逐字逐句慢慢看，都是飞快地浏览，并且脑袋中高速运转着，随时都想着我脑袋中的哪些问题怎么解决，这样带着问题看书的好处是，只要知识之间有一点的相关性，就能够非常敏锐地捕捉并关联上，然后再对这块知识进行深入学习，最终可以跳出单纯的知识本身去应用这些知识，甚至将一种知识的思维用来解决另一个问题。</p><p>整个一年中，我阅读了超过50本相关的书籍，并且大部分比较相关的知识都是反复阅读的。</p><p>早期我习惯使用iPhone的备忘录app记录一些想法，这种方式比较方便，任何时候想到一点东西就可以记下来，很多时候晚上半夜都会起来记录，确实有些东西很快就是可以忘记的。后来体系比较完整的时候我逐步将这些信息整理到Markdown中，并逐步积累，现在整个系统的设计和思考已经超过22万字，整整400多页，里面包含了非常多的技术理解和思考。等适当的时候我会将这些内容整理成图书出版。</p><p>豆瓣上我列了个top 10的图书榜单，编程相关的是：《编译原理》、《Erlang程序设计（第2版）》、《编程语言实现模式》、《游戏机制》、《链接器与加载器》、《Data-oriented design》、《函数式编程思维》、《凤凰架构》。</p><p>除了图书，一些技术架构对我影响比较大的是：Erlang、USD、LLVM、MLIR、ECS、Web Assembly、Machinations、《堡垒之夜》、Snapchat、Bevy等等。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="关于商业模式">关于商业模式<a href="#关于商业模式" class="hash-link" aria-label="Direct link to 关于商业模式" title="Direct link to 关于商业模式">​</a></h2><p>可能很多朋友会关心你的商业模式是什么，这里我不想讨论这个问题，目前只跟投资人之间才会讨论这个问题，我当然有很多思考，但是在缺乏很多背景下，我觉得现在在公众场合讨论还是太早。当然我不会介意大家讨论。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参与reality-world开发">参与Reality World开发<a href="#参与reality-world开发" class="hash-link" aria-label="Direct link to 参与Reality World开发" title="Direct link to 参与Reality World开发">​</a></h2><p>毫无疑问，Reality World涉及到很多技术思维，甚至包含一些创新尝试，我相信参与这个项目本身肯定会学到很多知识。但现阶段还不能正式公布，我们预计会在6个月左右，在内部迭代一些版本再正式公布，所以在这个阶段我也不会在公众场合讨论太多具体的技术细节。因为在中国做这种事情是非常不容易的，网络上会有各种各样的声音，我不希望受这种干扰，为了把这件事情做成，需要一颗安静的心。</p><p>如果你对Reality World感兴趣，你可以联系我，私人之间有时候我会讨论一些技术。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="关于融资">关于融资<a href="#关于融资" class="hash-link" aria-label="Direct link to 关于融资" title="Direct link to 关于融资">​</a></h2><p>坦白说，到目前为止，我还没有拿到任何投资，曾经有非常顶级的资本聊了很久，合伙人也非常认可这个项目的价值，但到现在还没有谈定。在早期，我肯定犯了很多错误，例如对项目的规划，估值预期，甚至表达等等都还是存在一些问题，当然也是一种成长；此外去年又遇到疫情，还有，你懂的，今年的ChatGPT...</p><p>总之，后续的开发肯定还是需要团队和资本，我一个人很难这样一直持续下午，欢迎各位感兴趣的资本、开发者甚至加油助威的朋友与我联系。</p><p>微信：ARealityWorld</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="后记">后记<a href="#后记" class="hash-link" aria-label="Direct link to 后记" title="Direct link to 后记">​</a></h2><p>在这一年过程中，我跟很多不同的朋友有过很多交流，很多朋友都在鼓励和支持，希望，最终不会辜负你们！</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/reality-world">Reality World</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Cogine</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/introduction">Introduction</a></li><li class="footer__item"><a class="footer__link-item" href="/philosophy">Architecture philosophy</a></li><li class="footer__item"><a class="footer__link-item" href="/community/questions">Questions</a></li></ul></div><div class="col footer__col"><div class="footer__title">Social</div><ul class="footer__items clean-list"><li class="footer__item">
              <span>Wechat 开源社区群:</span><br>
              <img src="/img/home/wechat.jpg" alt="Reality World开源社区群" width="150" height="150">
              <br><span>过期请加：ARealityWorld</span>
          </li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/Cogine/RealityWorld" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a class="footer__link-item" href="/">License</a></li></ul></div><div class="col footer__col"><div class="footer__title">About</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/commnuity/about-reality-world">Reality World</a></li><li class="footer__item"><a class="footer__link-item" href="/community/contact">Contact</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">2023 © Reality World.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.2fd98532.js"></script>
<script src="/assets/js/main.2db48ae4.js"></script>
</body>
</html>