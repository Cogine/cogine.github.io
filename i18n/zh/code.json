{
  "Whitepaper": {
    "message": "白皮书"
  },
  "theme.ErrorPageContent.title": {
    "message": "页面已崩溃。",
    "description": "The title of the fallback page when the page crashed"
  },
  "theme.NotFound.title": {
    "message": "找不到页面",
    "description": "The title of the 404 page"
  },
  "theme.NotFound.p1": {
    "message": "我们找不到您要找的页面。",
    "description": "The first paragraph of the 404 page"
  },
  "theme.NotFound.p2": {
    "message": "请联系原始链接来源网站的所有者，并告知他们链接已损坏。",
    "description": "The 2nd paragraph of the 404 page"
  },
  "theme.admonition.note": {
    "message": "备注",
    "description": "The default label used for the Note admonition (:::note)"
  },
  "theme.admonition.tip": {
    "message": "提示",
    "description": "The default label used for the Tip admonition (:::tip)"
  },
  "theme.admonition.danger": {
    "message": "危险",
    "description": "The default label used for the Danger admonition (:::danger)"
  },
  "theme.admonition.info": {
    "message": "信息",
    "description": "The default label used for the Info admonition (:::info)"
  },
  "theme.admonition.caution": {
    "message": "警告",
    "description": "The default label used for the Caution admonition (:::caution)"
  },
  "theme.BackToTopButton.buttonAriaLabel": {
    "message": "回到顶部",
    "description": "The ARIA label for the back to top button"
  },
  "theme.blog.archive.title": {
    "message": "历史博文",
    "description": "The page & hero title of the blog archive page"
  },
  "theme.blog.archive.description": {
    "message": "历史博文",
    "description": "The page & hero description of the blog archive page"
  },
  "theme.blog.paginator.navAriaLabel": {
    "message": "博文列表分页导航",
    "description": "The ARIA label for the blog pagination"
  },
  "theme.blog.paginator.newerEntries": {
    "message": "较新的博文",
    "description": "The label used to navigate to the newer blog posts page (previous page)"
  },
  "theme.blog.paginator.olderEntries": {
    "message": "较旧的博文",
    "description": "The label used to navigate to the older blog posts page (next page)"
  },
  "theme.blog.post.paginator.navAriaLabel": {
    "message": "博文分页导航",
    "description": "The ARIA label for the blog posts pagination"
  },
  "theme.blog.post.paginator.newerPost": {
    "message": "较新一篇",
    "description": "The blog post button label to navigate to the newer/previous post"
  },
  "theme.blog.post.paginator.olderPost": {
    "message": "较旧一篇",
    "description": "The blog post button label to navigate to the older/next post"
  },
  "theme.blog.post.plurals": {
    "message": "{count} 篇博文",
    "description": "Pluralized label for \"{count} posts\". Use as much plural forms (separated by \"|\") as your language support (see https://www.unicode.org/cldr/cldr-aux/charts/34/supplemental/language_plural_rules.html)"
  },
  "theme.blog.tagTitle": {
    "message": "{nPosts} 含有标签「{tagName}」",
    "description": "The title of the page for a blog tag"
  },
  "theme.tags.tagsPageLink": {
    "message": "查看所有标签",
    "description": "The label of the link targeting the tag list page"
  },
  "theme.colorToggle.ariaLabel": {
    "message": "切换浅色/暗黑模式（当前为{mode}）",
    "description": "The ARIA label for the navbar color mode toggle"
  },
  "theme.colorToggle.ariaLabel.mode.dark": {
    "message": "暗黑模式",
    "description": "The name for the dark color mode"
  },
  "theme.colorToggle.ariaLabel.mode.light": {
    "message": "浅色模式",
    "description": "The name for the light color mode"
  },
  "theme.docs.breadcrumbs.navAriaLabel": {
    "message": "页面路径",
    "description": "The ARIA label for the breadcrumbs"
  },
  "theme.docs.DocCard.categoryDescription": {
    "message": "{count} 个项目",
    "description": "The default description for a category card in the generated index about how many items this category includes"
  },
  "theme.docs.paginator.navAriaLabel": {
    "message": "文件选项卡",
    "description": "The ARIA label for the docs pagination"
  },
  "theme.docs.paginator.previous": {
    "message": "上一页",
    "description": "The label used to navigate to the previous doc"
  },
  "theme.docs.paginator.next": {
    "message": "下一页",
    "description": "The label used to navigate to the next doc"
  },
  "theme.docs.tagDocListPageTitle.nDocsTagged": {
    "message": "{count} 篇文档带有标签",
    "description": "Pluralized label for \"{count} docs tagged\". Use as much plural forms (separated by \"|\") as your language support (see https://www.unicode.org/cldr/cldr-aux/charts/34/supplemental/language_plural_rules.html)"
  },
  "theme.docs.tagDocListPageTitle": {
    "message": "{nDocsTagged}「{tagName}」",
    "description": "The title of the page for a docs tag"
  },
  "theme.docs.versionBadge.label": {
    "message": "版本：{versionLabel}"
  },
  "theme.docs.versions.unreleasedVersionLabel": {
    "message": "此为 {siteTitle} {versionLabel} 版尚未发行的文档。",
    "description": "The label used to tell the user that he's browsing an unreleased doc version"
  },
  "theme.docs.versions.unmaintainedVersionLabel": {
    "message": "此为 {siteTitle} {versionLabel} 版的文档，现已不再积极维护。",
    "description": "The label used to tell the user that he's browsing an unmaintained doc version"
  },
  "theme.docs.versions.latestVersionSuggestionLabel": {
    "message": "最新的文档请参阅 {latestVersionLink} ({versionLabel})。",
    "description": "The label used to tell the user to check the latest version"
  },
  "theme.docs.versions.latestVersionLinkLabel": {
    "message": "最新版本",
    "description": "The label used for the latest version suggestion link label"
  },
  "theme.common.editThisPage": {
    "message": "编辑此页",
    "description": "The link label to edit the current page"
  },
  "theme.common.headingLinkTitle": {
    "message": "{heading}的直接链接",
    "description": "Title for link to heading"
  },
  "theme.lastUpdated.atDate": {
    "message": "于 {date} ",
    "description": "The words used to describe on which date a page has been last updated"
  },
  "theme.lastUpdated.byUser": {
    "message": "由 {user} ",
    "description": "The words used to describe by who the page has been last updated"
  },
  "theme.lastUpdated.lastUpdatedAtBy": {
    "message": "最后{byUser}{atDate}更新",
    "description": "The sentence used to display when a page has been last updated, and by who"
  },
  "theme.navbar.mobileVersionsDropdown.label": {
    "message": "选择版本",
    "description": "The label for the navbar versions dropdown on mobile view"
  },
  "theme.tags.tagsListLabel": {
    "message": "标签：",
    "description": "The label alongside a tag list"
  },
  "theme.AnnouncementBar.closeButtonAriaLabel": {
    "message": "关闭",
    "description": "The ARIA label for close button of announcement bar"
  },
  "theme.blog.sidebar.navAriaLabel": {
    "message": "最近博文导航",
    "description": "The ARIA label for recent posts in the blog sidebar"
  },
  "theme.CodeBlock.copied": {
    "message": "复制成功",
    "description": "The copied button label on code blocks"
  },
  "theme.CodeBlock.copyButtonAriaLabel": {
    "message": "复制代码到剪贴板",
    "description": "The ARIA label for copy code blocks button"
  },
  "theme.CodeBlock.copy": {
    "message": "复制",
    "description": "The copy button label on code blocks"
  },
  "theme.CodeBlock.wordWrapToggle": {
    "message": "切换自动换行",
    "description": "The title attribute for toggle word wrapping button of code block lines"
  },
  "theme.DocSidebarItem.toggleCollapsedCategoryAriaLabel": {
    "message": "打开/收起侧边栏菜单「{label}」",
    "description": "The ARIA label to toggle the collapsible sidebar category"
  },
  "theme.NavBar.navAriaLabel": {
    "message": "主导航",
    "description": "The ARIA label for the main navigation"
  },
  "theme.navbar.mobileLanguageDropdown.label": {
    "message": "选择语言",
    "description": "The label for the mobile language switcher dropdown"
  },
  "theme.TOCCollapsible.toggleButtonLabel": {
    "message": "本页总览",
    "description": "The label used by the button on the collapsible TOC component"
  },
  "theme.blog.post.readMore": {
    "message": "阅读更多",
    "description": "The label used in blog post item excerpts to link to full blog posts"
  },
  "theme.blog.post.readMoreLabel": {
    "message": "阅读 {title} 的全文",
    "description": "The ARIA label for the link to full blog posts from excerpts"
  },
  "theme.blog.post.readingTime.plurals": {
    "message": "阅读需 {readingTime} 分钟",
    "description": "Pluralized label for \"{readingTime} min read\". Use as much plural forms (separated by \"|\") as your language support (see https://www.unicode.org/cldr/cldr-aux/charts/34/supplemental/language_plural_rules.html)"
  },
  "theme.docs.breadcrumbs.home": {
    "message": "主页面",
    "description": "The ARIA label for the home page in the breadcrumbs"
  },
  "theme.docs.sidebar.collapseButtonTitle": {
    "message": "收起侧边栏",
    "description": "The title attribute for collapse button of doc sidebar"
  },
  "theme.docs.sidebar.collapseButtonAriaLabel": {
    "message": "收起侧边栏",
    "description": "The title attribute for collapse button of doc sidebar"
  },
  "theme.docs.sidebar.navAriaLabel": {
    "message": "文档侧边栏",
    "description": "The ARIA label for the sidebar navigation"
  },
  "theme.docs.sidebar.closeSidebarButtonAriaLabel": {
    "message": "关闭导航栏",
    "description": "The ARIA label for close button of mobile sidebar"
  },
  "theme.docs.sidebar.toggleSidebarButtonAriaLabel": {
    "message": "切换导航栏",
    "description": "The ARIA label for hamburger menu button of mobile navigation"
  },
  "theme.navbar.mobileSidebarSecondaryMenu.backButtonLabel": {
    "message": "← 回到主菜单",
    "description": "The label of the back button to return to main menu, inside the mobile navbar sidebar secondary menu (notably used to display the docs sidebar)"
  },
  "theme.docs.sidebar.expandButtonTitle": {
    "message": "展开侧边栏",
    "description": "The ARIA label and title attribute for expand button of doc sidebar"
  },
  "theme.docs.sidebar.expandButtonAriaLabel": {
    "message": "展开侧边栏",
    "description": "The ARIA label and title attribute for expand button of doc sidebar"
  },
  "cmfcmf/d-s-l.searchBar.placeholder": {
    "message": "搜索...",
    "description": "Placeholder shown in the searchbar"
  },
  "cmfcmf/d-s-l.searchBar.clearButtonTitle": {
    "message": "清除",
    "description": "Title of the button to clear the current search input"
  },
  "cmfcmf/d-s-l.searchBar.detachedCancelButtonText": {
    "message": "取消",
    "description": "Text of the button to close the detached search window"
  },
  "cmfcmf/d-s-l.searchBar.submitButtonTitle": {
    "message": "搜索",
    "description": "Title of the button to submit a new search"
  },
  "cmfcmf/d-s-l.searchBar.noResults": {
    "message": "无搜索结果",
    "description": "message shown if no results are found"
  },
  "theme.ErrorPageContent.tryAgain": {
    "message": "重试",
    "description": "The label of the button to try again rendering when the React error boundary captures an error"
  },
  "theme.common.skipToMainContent": {
    "message": "跳到主要内容",
    "description": "The skip to content label used for accessibility, allowing to rapidly navigate to main content with keyboard tab/enter navigation"
  },
  "theme.tags.tagsPageTitle": {
    "message": "标签",
    "description": "The title of the tag list page"
  },
  "Read More": {
    "message": "阅读更多"
  },
  "Rality World is a multi-agent platform built with interoperability as its core, in which a dynamic agent or program can be added and interoperated with all other agents. It's like a complex system and emerges digital intelligence.": {
    "message": "Rality World是一个多程序（如多智能体）动态运行的平台和模拟器， 它的核心是解决这些来自不同开发者的程序之间的互操作、安全和调度。它像复杂系统一样工作，用户可以选择不同的程序组合，使得整体程序相比传统程序能够涌现出数字智能。"
  },
  "Get Started": {
    "message": "开始入门"
  },
  "Let everyone can write AI agent": {
    "message": "让每个人都可以编写AI智能体程序"
  },
  "Programming is not easy, but the hardest part is not the programming language itself, its the program structure organizing. We build a high level logic-abstraction to hide the structure and let developer focused on logic only.": {
    "message": "编写程序并不简单，但是其中最难的部分并不是编程语言本身，而是关于大规模程序怎样组织的方法，也即程序的结构，我们通过建立一个更高层次的逻辑抽象层来隐藏这种程序结构性，使开发者仅需要将注意力放到业务流程上。"
  },
  "Most visual graph editting is just a visual wrapper of the original codes. We build a graph interaction which is as simple as Houdini and as powerful as any turning completed programming language.": {
    "message": "大部分基于Graph的可视程序编辑只是对原始程序代码的一种可视化，这意味着开发者仍然需要关注结构性，基于我们调整的程序结构，我们构建出一种像Houdini一样简单的可视逻辑编辑交互，同时又和其它任何图灵完备的编程语言一样具有灵活的表达能力。"
  },
  "An agent VM, platform and simulator": {
    "message": "一个子程序的虚拟机、平台和模拟器"
  },
  "We then build a platform with a virtual machine to interpret and execute the above agent format program dynamically. By this dynamical capability, developer can create and share agent with users as simple as share a url.": {
    "message": "基于这种标准格式，我们开发了一个虚拟机用于动态解释和执行这种程序，这种动态性使得任何个人都可以开发和分享自己的个性化程序，就像分享一个URL那么简单，这将大大简化程序的创建和发布流程。"
  },
  "Multi-agent conversational collaborating framework": {
    "message": "多程序对话式协作框架"
  },
  "Agents can commnuicating with user, system and other agents in a very simple way which provides the ability to finish a task in a collaberating way.": {
    "message": "任何微程序可以以非常简单的方式与用户、系统和其它微程序进行通信，这提供一种能力通过使得程序之间通过协作的方式来完成复杂的任务。"
  },
  "In a LLM-powered application, the inputs of a function is semantic instead of structured data, which brings uncertainty and needs conversational way to get more information. For solve this problem, we propose a new concept and a novel architecture called \"Conversational computing\" for the first time in the world, to make any function can be paused and conversational commnuicating with user, system and other agents to get full information it needs without extra works.": {
    "message": "基于大模型（LLM）的应用，一个函数的输入是语义化的文本而不是结构化的数据，这给程序带来了很多不确定性，这需要通过多轮对话来澄清更多信息。为了解决这个问题，我们首次提出一种称为对话式计算（Conversational Computing）的概念和技术，使得任何函数都可以任意被暂停以与用户、系统或者其它微程序进行对话以获取更多信息，并在条件满足之后自动恢复执行，整个过程就像编写传统串行程序一样简单，不需要做一些额外繁琐的工作。"
  },
  "An engine of complexity to emerge intelligence": {
    "message": "基于复杂系统理论构建的复杂引擎"
  },
  "In biology or social economic syetm, many agreements have come to that the intelligence of the system come from the emergence mechanism of the complex system theory.": {
    "message": "在生物和社会经济系统中，人们普遍的共识是整个系统的智能来源于复杂系统理论中的涌现机制，这种涌现机制通过独立组件之间的局部协作、复制变异以及选择来实现。"
  },
  "In computer science and engineering, applications are isolated each other for data security and some other business reasons. The lack of interoperability make the applications non-cooperative and hence none-intelligent. We re-organized the structure and execution of software contruction process to provide a interopability-native architecture to form an engine of complexity.": {
    "message": "在计算机科学和工程中，应用之间通常是相互隔离以保证数据安全，这种互操作能力的缺失使得应用之间以非协作的方式运行，从而缺乏智能。我们通过对程序的结构和运行过程进行重新组织以提供一个原生互操作的计算架构，使整个系统像一个复杂引擎。"
  },
  "Conversational": {
    "message": "对话式计算"
  },
  "Code can talk to user, system or other agents to ask more information at any function location, the agent will be paused and continue to run when got response.": {
    "message": "每个函数可以任意跟用户、系统或其它程序进行任意通信以获取更多信息，该程序会被系统暂停直到获得响应后自动恢复执行，这种计算模型对LLM应用非常重要。"
  },
  "Interoperability": {
    "message": "互操作性"
  },
  "Agents written by different developers could be running in a same memory environment and interoperate with each other with the permission of user.": {
    "message": "来自不同开发者之间编写的程序可以运行在同一个内存环境，并在用户的许可下进行互操作，这种应用之间的协作能力是未来元宇宙和AI多智能体应用的核心基础需求。"
  },
  "Self-evolving": {
    "message": "自我进化"
  },
  "The agents are working in a collaborated way and user could custimize it's personal composation to make the whole system self-evolving and emerge digital intelligence.": {
    "message": "所有程序以相互协作的方式进行工作，用户可以定制个性化的组合以满足不同的个性需求，像生物系统一样进行自我进化，通过复杂系统的机制涌现出更高的数字智能。"
  },
  "Logic-abstraction": {
    "message": "逻辑抽象"
  },
  "We re-organized the whole program to make developers focused on logic of busniess and forget about the hardware, data and programing language abstraction.": {
    "message": "运行时将对整个程序进行重新组织，这使得开发者仅需要关注逻辑，而不需要关心硬件、内存数据管理以及其它编程语言相关的细节，从而建立一种逻辑抽象。"
  },
  "Computing Innovation": {
    "message": "计算架构创新"
  },
  "We defined a agent format standard to represent a turing completed agent program which can be loaded and runned dynamically so everyone can develop an agent to handle personal needs.": {
    "message": "我们定义了一个微程序（如AI智能体）的标准格式，它是图灵完备的程序，这个程序可以被动态加载和运行。"
  },
  "Join our developer community": {
    "message": "加入开发者社区"
  },
  "Cogine is the virtual machine and base framework of Reality World, it defined a standard agent(a micro-program) format, and it can load and run multi-agent dynamically with the ability to interoperate and communicate with each other.": {
    "message": "Cogine是Reality World的虚拟机和底层框架, 它定义了一套标准的微程序（例如一个LLM智能体）格式，这些微程序可以被动态的加载和运行， 微程序之间可以以很简单统一的方式进行通信。"
  },
  "The term Cogine stands for An engine of complexity, or an cognitive computing engine, or conversational computing engine.": {
    "message": "Cogine一词来源于几个相关的意思：An engine of complexity， 或者an cognitive computing engine, 或者 conversational computing engine。"
  },
  "And you can deploy it yourself within your own application.": {
    "message": "你也可以将Cogine部署集成到自己的应用中。"
  },
  "Reality World is an app which can load and run any agent defined by the Cogine agent format, it's also a simulator you can used to debug your agent program.": {
    "message": "Reality World是一个可以加载和运行遵循Cogine定义的Agent格式的应用， 它也是一个模拟器，开发者可以使用它调试Agent程序。"
  },
  "User who installed the Reality World app can create and share agent each other. It makes Reality World a agent platform.": {
    "message": "任何安装Reality World 应用的用户之间都可以很方便地创建和分享Agent程序，这使得它成为一个Agent开发和部署的平台。"
  },
  "Reality Create is a graph-based editor, it can create and define an agent program which will can be running in Reality World app or by the Cogine virtual machine": {
    "message": "Reality Create是一个基于图的编辑器，使用它可以创建由Cogine定义的程序，这些程序可以被Reality World加载或者Cogine虚拟机加载运行。"
  },
  "Features and benefits": {
    "message": "特性 和 好处"
  },
  "The following we list the main features of Cogine, for the details please check the technical documentation.": {
    "message": "以下是Cogine的一些主要特性，更详细的介绍参见技术文档"
  },
  "Development comparison with LangChain and Chidori": {
    "message": "与 LangChain 和 Chidori 在开发体验上的比较"
  },
  "Basically, in other framework, you have to learn Python language, have to care about the structure of the program and have to learn many architecture design (such as different specific class and its inheritance relationships. In Cogine, the only thing you are care about is your logic, no other programming burden.": {
    "message": "基本上，在使用其它框架的时候，用户必须要全面学习Python，关注程序的结构，以及这些框架本身定义的各种复杂的类及其复杂的继承关系，然后使用这些特定的架构规则构建程序。 使用Cogine，你唯一需要关心的就是逻辑本身， 没有太多软件构造方面的负担。"
  }
}
