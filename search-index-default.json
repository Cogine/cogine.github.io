{"documents":[{"id":1,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"对未来数字世界和软件构造的思考","sectionRoute":"/blog/thinking","type":"blog"},{"id":2,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"Reality World不是什么？","sectionRoute":"/blog/thinking#reality-world不是什么","type":"blog"},{"id":3,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"Reality Create的核心不是一个游戏引擎！","sectionRoute":"/blog/thinking#reality-create的核心不是一个游戏引擎","type":"blog"},{"id":4,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"Reality World当然也不是元宇宙项目","sectionRoute":"/blog/thinking#reality-world当然也不是元宇宙项目","type":"blog"},{"id":5,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"构建一个互操作的数字世界","sectionRoute":"/blog/thinking#构建一个互操作的数字世界","type":"blog"},{"id":6,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"更轻量级的隔离技术","sectionRoute":"/blog/thinking#更轻量级的隔离技术","type":"blog"},{"id":7,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"互操作性的本质是应用碎片化的问题","sectionRoute":"/blog/thinking#互操作性的本质是应用碎片化的问题","type":"blog"},{"id":8,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"新的应用程序构造方法","sectionRoute":"/blog/thinking#新的应用程序构造方法","type":"blog"},{"id":9,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"面向对象的本质是隔离","sectionRoute":"/blog/thinking#面向对象的本质是隔离","type":"blog"},{"id":10,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"程序结构的复杂性","sectionRoute":"/blog/thinking#程序结构的复杂性","type":"blog"},{"id":11,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"去中心化的数据管理","sectionRoute":"/blog/thinking#去中心化的数据管理","type":"blog"},{"id":12,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"为AI而生的应用程序构造方法","sectionRoute":"/blog/thinking#为ai而生的应用程序构造方法","type":"blog"},{"id":13,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"软件复用与可组合性","sectionRoute":"/blog/thinking#软件复用与可组合性","type":"blog"},{"id":14,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"面向AI的编程系统","sectionRoute":"/blog/thinking#面向ai的编程系统","type":"blog"},{"id":15,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"拥抱Rust","sectionRoute":"/blog/thinking#拥抱rust","type":"blog"},{"id":16,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"我这一年的创作过程","sectionRoute":"/blog/thinking#我这一年的创作过程","type":"blog"},{"id":17,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"关于商业模式","sectionRoute":"/blog/thinking#关于商业模式","type":"blog"},{"id":18,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"参与Reality World开发","sectionRoute":"/blog/thinking#参与reality-world开发","type":"blog"},{"id":19,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"关于融资","sectionRoute":"/blog/thinking#关于融资","type":"blog"},{"id":20,"pageTitle":"对未来数字世界和软件构造的思考","sectionTitle":"后记","sectionRoute":"/blog/thinking#后记","type":"blog"},{"id":21,"pageTitle":"","sectionTitle":"开源背景","sectionRoute":"/community/about-open-source#开源背景","type":"docs"},{"id":22,"pageTitle":"","sectionTitle":"开源目的","sectionRoute":"/community/about-open-source#开源目的","type":"docs"},{"id":23,"pageTitle":"","sectionTitle":"License","sectionRoute":"/community/about-open-source#license","type":"docs"},{"id":24,"pageTitle":"","sectionTitle":"特别说明","sectionRoute":"/community/about-open-source#特别说明","type":"docs"}],"index":{"version":"2.3.9","fields":["title","content","tags"],"fieldVectors":[["title/1",[0,0.24]],["content/1",[1,0.762,2,2.143,3,3.515,4,0.982,5,3.515,6,3.515]],["tags/1",[7,0.27]],["title/2",[1,0.37,4,0.477]],["content/2",[1,0.714,8,4.203,9,4.203]],["tags/2",[]],["title/3",[1,0.37,2,1.327]],["content/3",[0,0.346,1,0.561,2,2.011,4,0.723,10,3.299,11,3.299,12,3.299,13,3.299,14,3.299]],["tags/3",[]],["title/4",[1,0.37,4,0.477]],["content/4",[0,0.303,1,0.461,4,0.595,15,2.716,16,2.716,17,2.716,18,2.716,19,2.716,20,3.09,21,2.638,22,2.716,23,2.716,24,2.223,25,2.716]],["tags/4",[]],["title/5",[0,0.24]],["content/5",[0,0.221,1,0.466,4,0.601,20,1.443,21,1.617,26,1.028,27,1.028,28,1.028,29,1.028,30,1.028,31,1.028,32,1.028,33,1.028,34,1.028,35,1.028,36,1.028,37,1.028,38,1.028,39,1.028,40,1.028,41,1.028,42,1.028,43,1.028,44,1.028,45,1.028,46,1.028,47,1.028,48,1.028,49,1.028,50,1.028,51,0.841,52,1.028,53,1.028,54,1.028,55,1.028,56,1.028,57,1.028,58,1.443,59,1.028,60,1.028,61,1.028,62,0.841,63,1.028,64,1.028,65,1.028,66,1.028,67,1.028,68,1.028,69,1.763,70,1.028,71,1.028,72,0.841,73,1.028,74,1.028,75,1.028,76,1.028,77,1.028,78,1.028,79,1.028,80,1.028,81,1.028,82,1.028,83,1.028,84,1.028,85,1.028,86,1.028,87,1.028,88,1.028]],["tags/5",[]],["title/6",[0,0.24]],["content/6",[2,2.293,4,0.824,51,3.078,89,3.761,90,3.761,91,3.761]],["tags/6",[]],["title/7",[0,0.24]],["content/7",[0,0.393,1,0.38,4,0.371,21,0.685,24,0.803,92,0.981,93,0.981,94,0.981,95,0.981,96,0.981,97,0.981,98,0.981,99,0.981,100,0.981,101,1.693,102,0.981,103,0.981,104,3.283,105,0.981,106,0.981,107,0.981,108,3.001,109,1.693,110,0.803,111,0.981,112,1.693,113,0.981,114,1.693,115,1.386,116,0.981,117,0.981,118,0.981,119,0.981,120,1.693,121,0.981,122,0.981,123,1.693,124,0.981,125,0.981,126,1.386,127,0.981,128,0.981,129,0.981,130,0.981,131,0.981,132,0.981,133,0.981,134,0.981]],["tags/7",[]],["title/8",[0,0.24]],["content/8",[0,0.418,1,0.762,4,0.77,135,3.515]],["tags/8",[]],["title/9",[0,0.24]],["content/9",[0,0.207,58,1.333,62,1.333,72,0.768,110,0.768,115,1.333,126,0.768,136,0.938,137,1.629,138,1.629,139,0.938,140,0.938,141,0.938,142,0.938,143,1.629,144,0.938,145,0.938,146,1.629,147,0.938,148,0.938,149,1.629,150,0.938,151,1.629,152,0.938,153,3.202,154,2.111,155,0.938,156,0.938,157,3.202,158,3.202,159,0.938,160,0.938,161,0.938,162,0.938,163,0.938,164,1.629,165,0.938,166,0.938,167,0.938,168,0.938,169,0.938,170,0.938,171,0.938,172,0.938,173,0.938,174,0.938,175,0.938,176,0.938,177,0.938,178,0.938,179,0.938,180,0.938,181,0.938,182,0.938,183,0.938,184,0.938,185,0.938,186,0.938,187,0.938,188,0.938,189,0.938]],["tags/9",[]],["title/10",[0,0.24]],["content/10",[0,0.423,1,0.617,4,0.796,190,3.634]],["tags/10",[]],["title/11",[0,0.24]],["content/11",[0,0.416,191,3.898,192,3.898]],["tags/11",[]],["title/12",[193,2.446]],["content/12",[0,0.302,1,0.639,4,0.824,194,3.761,195,3.761,196,3.761]],["tags/12",[]],["title/13",[0,0.24]],["content/13",[0,0.379,1,0.544,197,3.201,198,3.201,199,3.201,200,3.201,201,3.201,202,3.201,203,2.62]],["tags/13",[]],["title/14",[193,2.446]],["content/14",[204,3.898,205,3.898,206,3.898,207,3.898,208,3.898]],["tags/14",[]],["title/15",[209,2.446]],["content/15",[209,3.078,210,3.761,211,3.761,212,3.761,213,3.761,214,3.761]],["tags/15",[]],["title/16",[0,0.24]],["content/16",[154,2.786,215,3.404,216,3.404,217,3.404,218,3.404,219,3.404,220,3.404,221,3.404,222,3.404]],["tags/16",[]],["title/17",[0,0.24]],["content/17",[0,0.366]],["tags/17",[]],["title/18",[1,0.37,4,0.477]],["content/18",[1,0.831,4,0.886,223,4.044]],["tags/18",[]],["title/19",[0,0.24]],["content/19",[0,0.338,203,3.439,224,4.203]],["tags/19",[]],["title/20",[0,0.24]],["content/20",[0,0.366]],["tags/20",[]],["title/21",[0,0.24]],["content/21",[0,0.366]],["tags/21",[]],["title/22",[0,0.24]],["content/22",[0,0.366]],["tags/22",[]],["title/23",[225,2.988]],["content/23",[0,0.366]],["tags/23",[]],["title/24",[0,0.24]],["content/24",[0,0.366]],["tags/24",[]]],"invertedIndex":[["",{"_index":0,"title":{"1":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"13":{},"16":{},"17":{},"19":{},"20":{},"21":{},"22":{},"24":{}},"content":{"3":{},"4":{},"5":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"17":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{}},"tags":{}}],["10的图书榜单，编程相关的是：《编译原理》、《erlang程序设计（第2版）》、《编程语言实现模式》、《游戏机制》、《链接器与加载器》、《data",{"_index":219,"title":{},"content":{"16":{}},"tags":{}}],["2022年4.30日从华为离职并开始研究和设计realiti",{"_index":195,"title":{},"content":{"12":{}},"tags":{}}],["2022年4.30日从华为离职，几乎整整一年时间全部都在思考整个系统的设计，以及后期的开发。刚开始2",{"_index":215,"title":{},"content":{"16":{}},"tags":{}}],["3d引擎的能力以使用户可以开发3d应用程序，但这部分技术跟传统的游戏引擎使用的技术不会有太大差异，当然因为运行时环境不同，与之相关的3d引擎的架构和流程肯定会有一些变化，所以我预期将来realiti",{"_index":12,"title":{},"content":{"3":{}},"tags":{}}],["3d渲染，realiti",{"_index":13,"title":{},"content":{"3":{}},"tags":{}}],["3d，然后期望人们有些更多沉浸式的虚拟生活。这在某种程度上说跟realiti",{"_index":15,"title":{},"content":{"4":{}},"tags":{}}],["3部分讨论的内容。然而比较巧合和惊讶的是，至少从我们的设计思路上看：让普通人会编写代码与让ai",{"_index":197,"title":{},"content":{"13":{}},"tags":{}}],["50",{"_index":216,"title":{},"content":{"16":{}},"tags":{}}],["7月左右，那个时候我的基本架构的构思已经初步完成，尤其是最核心也是最重要的一步基础已经设计好，当时看到这篇演讲感到很多共鸣，也是对自己的一种很大的激励，毕竟有对技术和行业都有非常经验和影响力的大佬也有类似的思考和行动。但从去年到现在，我们还是沿着我们早先的技术思路，基本上并没有去关注和参考太多epic",{"_index":29,"title":{},"content":{"5":{}},"tags":{}}],["ai",{"_index":193,"title":{"12":{},"14":{}},"content":{},"tags":{}}],["ai到底能不能或者什么时候替代程序员，我们回到问题本身。传统的文本合成，计算的是文字与文字之间，句子与句子之间的组合概率，这里有两个事情值得注意：第一是任何字之间都可以组合，所以chatgpt总是可以给我们答案，哪怕其中的句子组合和逻辑是完全错误的；第二是一般常用于表述正确语法和语义的哪些文字信息是非常多的，也就是说chatgpt",{"_index":199,"title":{},"content":{"13":{}},"tags":{}}],["ai去生成程序，这里ai",{"_index":202,"title":{},"content":{"13":{}},"tags":{}}],["ai构造复杂的程序逻辑相比，更好的使用方式可能是autogpt或者openai的插件系统，在这种架构中，ai",{"_index":204,"title":{},"content":{"14":{}},"tags":{}}],["ai能够生成代码，这件事情肯定是非常复杂的，当然由于chatgpt的出现相信现在大部分程序员都能够感受到ai的代码生成能力，有些人比较坚信ai",{"_index":198,"title":{},"content":{"13":{}},"tags":{}}],["alan",{"_index":146,"title":{},"content":{"9":{}},"tags":{}}],["alway",{"_index":169,"title":{},"content":{"9":{}},"tags":{}}],["api从哪里获取等等，这远远超出简单文字合成的范围。你可以合成一个文本组合的源代码结果，但是其中的逻辑可能完全是错误的，函数是不存在的，参数是错误的。因此目前来讲，大部分ai",{"_index":200,"title":{},"content":{"13":{}},"tags":{}}],["api包装使用某种形式的标准包装成外部接口，这样就造成碎片化，因为即使是针对同样的一类逻辑和数据，不同的应用程序或服务往往会定义不同的数据结构或处理逻辑，这就形成api的碎片化，使得相互之间非常难以协作。试想你可以在两个应用之间协商修改各自的api",{"_index":96,"title":{},"content":{"7":{}},"tags":{}}],["api碎片化的第二个例子是llvm，本质上llvm在编译器领域的创新主要做的是模块化，早期的编译器开发，各个前端都要分别集成各个后端，编译器开发的复杂度非常高，这里面其实就是多对多的问题，看似很简单，每个前端与每个后端分别调一调，但随之代码的管理和维护成本是很高的，有时候某些内部设计不一致就会导致大量的重复，这就是碎片化问题。由内而外的设计总是不可避免会导致碎片化，碎片化带来软件复杂度，管理和研发成本。当llvm提供了一个统一的低层ir表述之后，编译器的复杂度大大降低，比如现在能够很轻易地开发一些dsl语言，因为你完全不需要操心后端，只需要把你的代码生成llvm",{"_index":100,"title":{},"content":{"7":{}},"tags":{}}],["app",{"_index":35,"title":{},"content":{"5":{}},"tags":{}}],["applic",{"_index":23,"title":{},"content":{"4":{}},"tags":{}}],["arealityworld",{"_index":224,"title":{},"content":{"19":{}},"tags":{}}],["armstrong",{"_index":143,"title":{},"content":{"9":{}},"tags":{}}],["armstrong的一段采访：ralph",{"_index":140,"title":{},"content":{"9":{}},"tags":{}}],["armstrong觉得oo编程很烂？，其中引用到erlang之父jo",{"_index":139,"title":{},"content":{"9":{}},"tags":{}}],["armstrong说，根据alan",{"_index":176,"title":{},"content":{"9":{}},"tags":{}}],["assembl",{"_index":56,"title":{},"content":{"5":{}},"tags":{}}],["assembly、machinations、《堡垒之夜》、snapchat、bevi",{"_index":222,"title":{},"content":{"16":{}},"tags":{}}],["assembly之前还没有一种技术可以很好地普及和运用沙盒技术，例如jvm上有一些方案，但大多有些性能问题，或者不能完全保证安全，或者方案比较重。web",{"_index":53,"title":{},"content":{"5":{}},"tags":{}}],["assembly之所以是一种未来非常有潜力的技术，不仅仅得益于对web的友好，接近机器码的字节码，多语言支持等等，这种沙盒技术也是很大的一个技术点。在web",{"_index":52,"title":{},"content":{"5":{}},"tags":{}}],["assembly就使用另一个思路，由于web",{"_index":44,"title":{},"content":{"5":{}},"tags":{}}],["assembly有机会对程序进行一定的分析，通过基于control",{"_index":46,"title":{},"content":{"5":{}},"tags":{}}],["assembly的编译器可以检查出程序中哪些代码可能会对这种沙盒环境造成破坏，从而禁止这样的代码生成合法的wasm",{"_index":50,"title":{},"content":{"5":{}},"tags":{}}],["assembly的隔离技术非常优异，但是它并没有改变程序本身的构造方式，即如果你的代码本身就不含破坏别人的恶意代码，那么其实你的开发过程与过去的方式并没有什么区别。而r",{"_index":89,"title":{},"content":{"6":{}},"tags":{}}],["assembly程序都会编译为wasm文件，由wasm虚拟机解释执行，而不是底层的二进制代码，所以web",{"_index":45,"title":{},"content":{"5":{}},"tags":{}}],["assembly这种优秀的沙盒技术使得沙盒模式在以后的软件构造中可能被大规模使用，也就会实现更多的软件协作与分工，事实上比如现在对未受信任多应用环境要求比较高的环境如区块链就大多转型web",{"_index":54,"title":{},"content":{"5":{}},"tags":{}}],["assembly，而如docker和severless这种对虚拟环境要求比较高的环境也在逐步转向web",{"_index":55,"title":{},"content":{"5":{}},"tags":{}}],["a开发了某个应用给用户新增了一种新的健康类的数据信息，这个数据本来是属于用户的，这个时候用户想要用这个数据来实现另一个事情，ta想自己或者说让其他开发者b帮助开发一个应用来使用这些数据，这种情况下通常是做不到的，因为开发者a可能并没有太多动力去提供这个接口，因为ta可能要耗费很大的精力，除非平台提供一些这种非常便利的机制使得ta",{"_index":95,"title":{},"content":{"7":{}},"tags":{}}],["back",{"_index":173,"title":{},"content":{"9":{}},"tags":{}}],["base",{"_index":37,"title":{},"content":{"5":{}},"tags":{}}],["bit",{"_index":184,"title":{},"content":{"9":{}},"tags":{}}],["bug",{"_index":33,"title":{},"content":{"5":{}},"tags":{}}],["c",{"_index":114,"title":{},"content":{"7":{}},"tags":{}}],["c#、c、c++、ruby、lua、rust",{"_index":136,"title":{},"content":{"9":{}},"tags":{}}],["c++/c进行开发，进行了一些简单的语言包装和编译流程定制。因为我们2号员工一直是rust爱好者，一直在鼓动我使用rust，虽然之前看过rust的一些介绍，但是感觉还是没有特别的动力去完全切换到rust",{"_index":210,"title":{},"content":{"15":{}},"tags":{}}],["c++中也经常会存在对象复制；再有稍微复杂一点就是使用move，先将数据mov",{"_index":214,"title":{},"content":{"15":{}},"tags":{}}],["c++那样到处是相互引用显然几乎肯定是你完全没法通过编译器，你得设计好整个程序对象的结构，这里推荐bevi",{"_index":213,"title":{},"content":{"15":{}},"tags":{}}],["call",{"_index":90,"title":{},"content":{"6":{}},"tags":{}}],["capabl",{"_index":77,"title":{},"content":{"5":{}},"tags":{}}],["cfi)技术，web",{"_index":49,"title":{},"content":{"5":{}},"tags":{}}],["characterist",{"_index":68,"title":{},"content":{"5":{}},"tags":{}}],["chatgpt",{"_index":203,"title":{},"content":{"13":{},"19":{}},"tags":{}}],["chatgpt席卷了整个世界，或者至少是科技圈，不管是从资本，国企，民企，程序员个人等等都是受到很大的影响，当然也有像我们小孩的妈妈，以及他妈妈的朋友，目前还不太了解chatgpt",{"_index":194,"title":{},"content":{"12":{}},"tags":{}}],["class",{"_index":115,"title":{},"content":{"7":{},"9":{}},"tags":{}}],["client",{"_index":40,"title":{},"content":{"5":{}},"tags":{}}],["common",{"_index":84,"title":{},"content":{"5":{}},"tags":{}}],["commondata",{"_index":74,"title":{},"content":{"5":{}},"tags":{}}],["commun",{"_index":78,"title":{},"content":{"5":{}},"tags":{}}],["complet",{"_index":155,"title":{},"content":{"9":{}},"tags":{}}],["compos",{"_index":25,"title":{},"content":{"4":{}},"tags":{}}],["context",{"_index":123,"title":{},"content":{"7":{}},"tags":{}}],["convention）来设计隔离机制，这样使得不需要对用户的开发过程造成太大的影响。在r",{"_index":91,"title":{},"content":{"6":{}},"tags":{}}],["cppnamespac",{"_index":118,"title":{},"content":{"7":{}},"tags":{}}],["creat",{"_index":2,"title":{"3":{}},"content":{"1":{},"3":{},"6":{}},"tags":{}}],["create也包含的3d支持，在我与投资人或者其他朋友交流的过程中，大家普遍的印象是这是一个新的游戏引擎，所以大家的思路就是你跟unity，unr",{"_index":8,"title":{},"content":{"2":{}},"tags":{}}],["create的计划也可以开发2d应用程序，所以我们是用一种统一的编程语言和运行时环境，来统一3d和传统2d",{"_index":14,"title":{},"content":{"3":{}},"tags":{}}],["creativ",{"_index":32,"title":{},"content":{"5":{}},"tags":{}}],["c接口实现相互调用，再往上一点，任何程序之间传递字符串然后内部进行格式解释，也仍然是能够进行通信的。实际上互联网的机制就是如此，osi（open",{"_index":92,"title":{},"content":{"7":{}},"tags":{}}],["data",{"_index":85,"title":{},"content":{"5":{}},"tags":{}}],["def",{"_index":105,"title":{},"content":{"7":{}},"tags":{}}],["definit",{"_index":116,"title":{},"content":{"7":{}},"tags":{}}],["descript",{"_index":109,"title":{},"content":{"7":{}},"tags":{}}],["design",{"_index":220,"title":{},"content":{"16":{}},"tags":{}}],["dialect",{"_index":104,"title":{},"content":{"7":{}},"tags":{}}],["each",{"_index":79,"title":{},"content":{"5":{}},"tags":{}}],["emphas",{"_index":163,"title":{},"content":{"9":{}},"tags":{}}],["engin",{"_index":9,"title":{},"content":{"2":{}},"tags":{}}],["engine去创作，这个模式其实类似roblox的模式，它也是一种游戏引擎这种商业模式的转型：传统的游戏引擎只是一个单机的生成应用程序的软件，开发者开发的内容由自己去分发和运营，这样游戏引擎仅作为一个工具，它只参与程序的开发，而无法参与分发和运营，因此无法形成生态，所以尽管一些引擎有庞大的开发者数量和群体，但是这种数量并没有很有效的方式可以转化为生态。然而roblox和《堡垒之夜》是一个分布式系统，你的内容必须分发到这个分布式系统中并由特定的客户端运行时环境来运行，而无法像单独的游戏引擎那样自行分发和运营，这样roblox",{"_index":31,"title":{},"content":{"5":{}},"tags":{}}],["engine开发脚本语言的团队skookumscript，据说还有写v8",{"_index":66,"title":{},"content":{"5":{}},"tags":{}}],["engine的c++或者blueprint开发的应用程序在《堡垒之夜》内存环境中运行，unr",{"_index":60,"title":{},"content":{"5":{}},"tags":{}}],["engine目前也没有比较成熟的脚本编程语言方案，因此epic需要开发一套新的脚本语言，这就是今年早些时候发布的vers",{"_index":61,"title":{},"content":{"5":{}},"tags":{}}],["epic推出vers",{"_index":57,"title":{},"content":{"5":{}},"tags":{}}],["epic显然不可能让玩家使用unr",{"_index":59,"title":{},"content":{"5":{}},"tags":{}}],["erlang",{"_index":137,"title":{},"content":{"9":{}},"tags":{}}],["erlang、usd、llvm、mlir、ecs、web",{"_index":221,"title":{},"content":{"16":{}},"tags":{}}],["erlang之父jo",{"_index":138,"title":{},"content":{"9":{}},"tags":{}}],["erlang就采用了一种不同的机制，它从语言体系上就不允许对象之间能够直接访问内部数据或方法，每个函数都分配为独立的线程，线程之间只能通过消息进行传递和联系，这样程序员就很难写出耦合比较深的代码，同时这种隔离对并行计算和分布式也带来了好处。所以jo",{"_index":175,"title":{},"content":{"9":{}},"tags":{}}],["erlang的整个架构设计，这也是为什么erlang",{"_index":187,"title":{},"content":{"9":{}},"tags":{}}],["erlang看起来是一种完美的架构，然而消息通信是一种操作起来不太便利的方式，比如为了进一步解耦它通常是传递字符串消息，字符串需要编解码，带来了性能问题；而另一方面消息编程模型通常是异步的，使得对逻辑的流程管理失去了控制力。r",{"_index":188,"title":{},"content":{"9":{}},"tags":{}}],["evolv",{"_index":19,"title":{},"content":{"4":{}},"tags":{}}],["exampl",{"_index":83,"title":{},"content":{"5":{}},"tags":{}}],["exhibitsyntact",{"_index":80,"title":{},"content":{"5":{}},"tags":{}}],["famou",{"_index":150,"title":{},"content":{"9":{}},"tags":{}}],["fault",{"_index":38,"title":{},"content":{"5":{}},"tags":{}}],["flow",{"_index":47,"title":{},"content":{"5":{}},"tags":{}}],["format",{"_index":86,"title":{},"content":{"5":{}},"tags":{}}],["formatsandcommun",{"_index":75,"title":{},"content":{"5":{}},"tags":{}}],["getdialectnamespac",{"_index":129,"title":{},"content":{"7":{}},"tags":{}}],["graphql",{"_index":192,"title":{},"content":{"11":{}},"tags":{}}],["grapql",{"_index":191,"title":{},"content":{"11":{}},"tags":{}}],["himself",{"_index":148,"title":{},"content":{"9":{}},"tags":{}}],["html、xml、sql、usd等等，比如nvidia就基于usd构建了omniverse，由于其对usd格式的良好支持，使得其可以兼容大部分的内容制作工具，就构建起一个以omnivers",{"_index":94,"title":{},"content":{"7":{}},"tags":{}}],["initi",{"_index":126,"title":{},"content":{"7":{},"9":{}},"tags":{}}],["integr",{"_index":48,"title":{},"content":{"5":{}},"tags":{}}],["interconnect",{"_index":93,"title":{},"content":{"7":{}},"tags":{}}],["interoper",{"_index":20,"title":{},"content":{"4":{},"5":{}},"tags":{}}],["iphone的备忘录app记录一些想法，这种方式比较方便，任何时候想到一点东西就可以记下来，很多时候晚上半夜都会起来记录，确实有些东西很快就是可以忘记的。后来体系比较完整的时候我逐步将这些信息整理到markdown中，并逐步积累，现在整个系统的设计和思考已经超过22万字，整整400",{"_index":217,"title":{},"content":{"16":{}},"tags":{}}],["ir",{"_index":101,"title":{},"content":{"7":{}},"tags":{}}],["ir就可以能够被轻易组合使用，你可以选择社区各种丰富的模块进行组合，来生成特定的编译流程，所以mlir又称作“生成编译器的编译器”。实际上，碎片化在工业界是一个很大的问题，每家公司在开发自己的软件的时候不会考虑那么多，觉得我只要投入研发资源把自己软件做好就行，但是真正在用户侧使用的时候，ta可能需要多个软件是可以相互协作的，甚至你的用户可能就是开发者，这个开发者可能希望不同的软件可以被更高效的集成和管理。llvm的作者chri",{"_index":132,"title":{},"content":{"7":{}},"tags":{}}],["ir更上层的抽象，所以我们对多层级ir表述又有了需求，于是在llvm的基础上又发展出mlir，它允许开发者社区能够自定义ir。然而与usd的schema非常相似的地方是，mlir为了避免碎片化，使不同开发者自定义的ir之间能够更轻易的协作，它也提供了一种类似的代码生成机制，在mlir中称为dialect",{"_index":103,"title":{},"content":{"7":{}},"tags":{}}],["isol",{"_index":178,"title":{},"content":{"9":{}},"tags":{}}],["isolation，sfi）技术，相对应操作系统或硬件的内存隔离，sfi是用于构建包含未信任组件的安全系统的一种轻量级方法，能够用于减少由于内存安全bug导致的攻击，sfi通过严格将第三方未信任软件限制在自己的沙盒内存区域，来隔离这种内存安全导致的破坏。用例包括浏览器使用sfi来扩展第三方组件，例如经典的n",{"_index":39,"title":{},"content":{"5":{}},"tags":{}}],["it'",{"_index":157,"title":{},"content":{"9":{}},"tags":{}}],["joe",{"_index":142,"title":{},"content":{"9":{}},"tags":{}}],["johnson",{"_index":141,"title":{},"content":{"9":{}},"tags":{}}],["jones，以及之前收购的一个为unr",{"_index":65,"title":{},"content":{"5":{}},"tags":{}}],["kay",{"_index":147,"title":{},"content":{"9":{}},"tags":{}}],["kay的描述，erlang",{"_index":177,"title":{},"content":{"9":{}},"tags":{}}],["kay认为oop的核心是关于消息，但是这样说其实我个人觉得并不太好理解到本质，因为消息更像是oop这种设计下的一种机制或结果，而不是oop本身的定义。我觉得oop的本质应该是隔离，只有做到真正的隔离，才能真正降低系统的复杂度，因为绝对的隔离使得你完全不需要也不能了解另一个物体内部的运作，你们只需要通过一些外在的属性进行交互，我们的开发也仅需要了解这些简单的外在属性。现代大部分编程语言更强调的是object和class",{"_index":174,"title":{},"content":{"9":{}},"tags":{}}],["languag",{"_index":58,"title":{},"content":{"5":{},"9":{}},"tags":{}}],["language。epic为此挖来了haskell的作者simon",{"_index":63,"title":{},"content":{"5":{}},"tags":{}}],["lattner最新的创业公司modular实际上核心就是解决这个问题，他的新编程语言mojo，除了一些语法层面的传统一点的东西，很多核心能力都是来源于底层的mlir，其中mlir跟mojo有更深度的整合，使得mojo具有很强的元编程能力。modular的最核心的逻辑其实跟当年的llvm类似，解决碎片化问题，当然modular",{"_index":133,"title":{},"content":{"7":{}},"tags":{}}],["licens",{"_index":225,"title":{"23":{}},"content":{},"tags":{}}],["llvm::stringref",{"_index":128,"title":{},"content":{"7":{}},"tags":{}}],["llvm并没有提供类似usd那种生成格式的机制，那是因为llvm只有一种ir，所以写成一种固定的格式即可，过去的编译流程基本上都比较简单、固定。但是随着现代深度学习编译器的进展，由于深度学习有着相对比较特定的数据表述，各个公司内部都有开发一些特定的编译流程，它是比一般的llvm",{"_index":102,"title":{},"content":{"7":{}},"tags":{}}],["longer",{"_index":111,"title":{},"content":{"7":{}},"tags":{}}],["lot",{"_index":165,"title":{},"content":{"9":{}},"tags":{}}],["lua，它们通常不能直接访问内存，开发者所能操作的都是封装在一定类型和对象中，现代大多数编程语言都按照类型进行寻址，也即是类型系统本身基本上可以保证程序的安全，如果你的源代码不知道一个对象的地址，你就不可能访问到它。然而实际现在大多数编程语言都提供静态变量或者全局常量之类的方式，这种方式使得内存环境中的其他代码可以获取到这些共享信息，从而对软件进行破坏。为了避免这种问题，roblox就对lua进行了改造，叫做luau，比如通过禁止全局变量，以及禁止一些能够访问全局变量的库函数等等机制来实现一种沙盒安全，这样第三方开发者开发的代码就可以放心地在roblox",{"_index":34,"title":{},"content":{"5":{}},"tags":{}}],["messag",{"_index":158,"title":{},"content":{"9":{}},"tags":{}}],["method",{"_index":161,"title":{},"content":{"9":{}},"tags":{}}],["misunderstood",{"_index":156,"title":{},"content":{"9":{}},"tags":{}}],["mlir::dialect",{"_index":121,"title":{},"content":{"7":{}},"tags":{}}],["mlir::dialect(\"toy",{"_index":124,"title":{},"content":{"7":{}},"tags":{}}],["mlir::typeid::get<toydialect",{"_index":125,"title":{},"content":{"7":{}},"tags":{}}],["modular",{"_index":24,"title":{},"content":{"4":{},"7":{}},"tags":{}}],["more",{"_index":72,"title":{},"content":{"5":{},"9":{}},"tags":{}}],["much",{"_index":110,"title":{},"content":{"7":{},"9":{}},"tags":{}}],["multi",{"_index":22,"title":{},"content":{"4":{}},"tags":{}}],["naci存在较大的运行时性能，因为它的机制一般对第三方代码不做太多要求，假设其按照一般的方法进行开发，然后仅仅在调用这些方法的时候为其分配独立的内存区域进行隔离，它基本上是用软件模拟操作系统的内存隔离机制，比如每次切换都需要保存大量的状态和寄存器地址等等。为了减少这种隔离导致的代价，web",{"_index":43,"title":{},"content":{"5":{}},"tags":{}}],["name",{"_index":113,"title":{},"content":{"7":{}},"tags":{}}],["namespac",{"_index":112,"title":{},"content":{"7":{}},"tags":{}}],["nicer",{"_index":166,"title":{},"content":{"9":{}},"tags":{}}],["notion",{"_index":152,"title":{},"content":{"9":{}},"tags":{}}],["object",{"_index":153,"title":{},"content":{"9":{}},"tags":{}}],["oop",{"_index":145,"title":{},"content":{"9":{}},"tags":{}}],["openai的plugin系统中，每个plugin是一个特定的应用，尽管这种描述好的调用逻辑使得chatgpt可以正确地调用各个应用软件的接口，但如果你的使用本身是要在多个plugin之间建立一些比较复杂的逻辑和流程，或者说我们想构造任意的应用程序，把每个plugin接口当作组件，这就又会回到让ai",{"_index":205,"title":{},"content":{"14":{}},"tags":{}}],["orient",{"_index":154,"title":{},"content":{"9":{},"16":{}},"tags":{}}],["origin",{"_index":167,"title":{},"content":{"9":{}},"tags":{}}],["overemphas",{"_index":160,"title":{},"content":{"9":{}},"tags":{}}],["perhap",{"_index":183,"title":{},"content":{"9":{}},"tags":{}}],["peyton",{"_index":64,"title":{},"content":{"5":{}},"tags":{}}],["pixar",{"_index":97,"title":{},"content":{"7":{}},"tags":{}}],["plugin系统，r",{"_index":206,"title":{},"content":{"14":{}},"tags":{}}],["point",{"_index":181,"title":{},"content":{"9":{}},"tags":{}}],["polymorph",{"_index":179,"title":{},"content":{"9":{}},"tags":{}}],["prematur",{"_index":185,"title":{},"content":{"9":{}},"tags":{}}],["product",{"_index":69,"title":{},"content":{"5":{}},"tags":{}}],["program",{"_index":62,"title":{},"content":{"5":{},"9":{}},"tags":{}}],["protocol",{"_index":87,"title":{},"content":{"5":{}},"tags":{}}],["protocolsand",{"_index":76,"title":{},"content":{"5":{}},"tags":{}}],["public",{"_index":120,"title":{},"content":{"7":{}},"tags":{}}],["pure",{"_index":180,"title":{},"content":{"9":{}},"tags":{}}],["reaction",{"_index":159,"title":{},"content":{"9":{}},"tags":{}}],["realiti",{"_index":1,"title":{"2":{},"3":{},"4":{},"18":{}},"content":{"1":{},"2":{},"3":{},"4":{},"5":{},"7":{},"8":{},"10":{},"12":{},"13":{},"18":{}},"tags":{}}],["reality world",{"_index":7,"title":{},"content":{},"tags":{"1":{}}}],["resid",{"_index":117,"title":{},"content":{"7":{}},"tags":{}}],["respond",{"_index":171,"title":{},"content":{"9":{}},"tags":{}}],["return",{"_index":130,"title":{},"content":{"7":{}},"tags":{}}],["rust",{"_index":209,"title":{"15":{}},"content":{"15":{}},"tags":{}}],["rust对我而言最大的好处和体验是，迭代速度比较快，这符合我现在的需求。只要代码编译通过，几乎不会花时间去排查一些比较诡异，甚至需要小心翼翼地断步调试才能发现问题的bug，一般有bug就基本上大部分还是逻辑问题，而且rust",{"_index":212,"title":{},"content":{"15":{}},"tags":{}}],["rust进行开发，开始也是有些不习惯，但是在逐步学习和使用过程中感受到了rust",{"_index":211,"title":{},"content":{"15":{}},"tags":{}}],["say",{"_index":186,"title":{},"content":{"9":{}},"tags":{}}],["scratch",{"_index":190,"title":{},"content":{"10":{}},"tags":{}}],["self",{"_index":18,"title":{},"content":{"4":{}},"tags":{}}],["send",{"_index":172,"title":{},"content":{"9":{}},"tags":{}}],["sent",{"_index":170,"title":{},"content":{"9":{}},"tags":{}}],["sfi",{"_index":41,"title":{},"content":{"5":{}},"tags":{}}],["smalltalk",{"_index":168,"title":{},"content":{"9":{}},"tags":{}}],["softwar",{"_index":36,"title":{},"content":{"5":{}},"tags":{}}],["sql",{"_index":82,"title":{},"content":{"5":{}},"tags":{}}],["state",{"_index":144,"title":{},"content":{"9":{}},"tags":{}}],["static",{"_index":127,"title":{},"content":{"7":{}},"tags":{}}],["summari",{"_index":107,"title":{},"content":{"7":{}},"tags":{}}],["sweeney的那篇演讲：https://dl.acm.org/doi/10.1145/3306307.3339844",{"_index":27,"title":{},"content":{"5":{}},"tags":{}}],["syetem（naci）使用sfi来扩展第三方c库，使得浏览器可以使用如第三方的字体，音频，xml",{"_index":42,"title":{},"content":{"5":{}},"tags":{}}],["system",{"_index":21,"title":{},"content":{"4":{},"5":{},"7":{}},"tags":{}}],["talk",{"_index":164,"title":{},"content":{"9":{}},"tags":{}}],["thing",{"_index":151,"title":{},"content":{"9":{}},"tags":{}}],["tim",{"_index":26,"title":{},"content":{"5":{}},"tags":{}}],["tim在2019年的演讲中大量提到了标准，为了实现多个独立应用程序之间的协作，那么必然要建立大量的标准，有了这些标准，互操作就变得简单，例如《堡垒之夜》现在的creative模式实际上已经有了很多标准，比如一个物体怎么摆放在环境中，并可以被其他玩家交互，这都是可以由device来定义的，这实际上就是一种形式的标准或者接口，后续基于vers",{"_index":88,"title":{},"content":{"5":{}},"tags":{}}],["tim认为这样的目标大概可能需要10年才能完成，但epic会朝着这个目标逐步逼近。epic的路线大概是几步：首先将一些偏社交或者玩家的非专业游戏开发者转移到《堡垒之夜》中，这部分开发者都在《堡垒之夜》的游戏内部而不是单独使用unr",{"_index":30,"title":{},"content":{"5":{}},"tags":{}}],["top",{"_index":218,"title":{},"content":{"16":{}},"tags":{}}],["toy",{"_index":108,"title":{},"content":{"7":{}},"tags":{}}],["toy_dialect",{"_index":106,"title":{},"content":{"7":{}},"tags":{}}],["toydialect",{"_index":119,"title":{},"content":{"7":{}},"tags":{}}],["toydialect(mlir::mlircontext",{"_index":122,"title":{},"content":{"7":{}},"tags":{}}],["two",{"_index":71,"title":{},"content":{"5":{}},"tags":{}}],["under",{"_index":162,"title":{},"content":{"9":{}},"tags":{}}],["us",{"_index":73,"title":{},"content":{"5":{}},"tags":{}}],["usd",{"_index":98,"title":{},"content":{"7":{}},"tags":{}}],["usd格式，尽管从表面看usd跟其他的标准类似只是一种数据格式或协议，但实际上它远远不止如此，它还是一种非常易于扩展的格式，它提供了一种plugin的机制使得开发者可以对格式做很多定制和增强功能，并且可以通过一个schema定义来生成自己定义格式的解析代码，然后通过plugin来调用自定义的格式解析和代码。这就好比它帮助你编写了文本格式的编解码，尽管看起来不过如此，看起来只是一种模板化的代码生成机制，但是当这种解析代码能够与逻辑高度融为一体的时候，事情的本质发生了一些变化，试想使用usd你的流程是这样：首先针对一种特定数据自定义一个schema，然后调用usd的api帮助我们生成相关的解析代码，如果这段解析代码能够以某种机制被其他开发者拿到，那么ta的程序就能够轻松解析我们的api。当然如果你修改了schema，仍然需要对方进行同步，但是这种流程本质上改变了我们的思路：过去我们是先定义内部做法，再与外界沟通，这就容易带来一些复杂度和碎片化；现在是我们先想着自己就是基于一种标准在开发，然后需要的时候就能够很方便地暴露出去，这里usd充当了一种协调的机制并为这种协调的机制提供了一些辅助功能。苹果的usdz格式以及英伟达的mdl都是基于usd",{"_index":99,"title":{},"content":{"7":{}},"tags":{}}],["v0.1.0版本的开发，它实现了realiti",{"_index":3,"title":{},"content":{"1":{}},"tags":{}}],["vers",{"_index":67,"title":{},"content":{"5":{}},"tags":{}}],["view",{"_index":182,"title":{},"content":{"9":{}},"tags":{}}],["void",{"_index":131,"title":{},"content":{"7":{}},"tags":{}}],["web",{"_index":51,"title":{},"content":{"5":{},"6":{}},"tags":{}}],["work",{"_index":70,"title":{},"content":{"5":{}},"tags":{}}],["world",{"_index":4,"title":{"2":{},"4":{},"18":{}},"content":{"1":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"10":{},"12":{},"18":{}},"tags":{}}],["world创业的事情，然而很遗憾的是一直没有分享太多关于它的信息。一来是因为它所涉及的技术有比较多的创新尝试，在还没有真正的技术开发实践之前容易引起比较多的争议；二来是因为去年得到了一些大资本极大的兴趣，因此我想着一鼓作气等拿到投资之后再公布一些信息。当然因为各种原因到现在也还没有谈定投资，所以近几个月我就将全部精力用于开发了。经过几个月的艰苦奋战，今天终于有机会可以给大家分享一些我的想法，以及这一年的探索过程。当然real",{"_index":5,"title":{},"content":{"1":{}},"tags":{}}],["world在这两个方面都做了一些创新尝试，使得开发者既可以像传统的局部变量一样去方面其它对象的数据，又可以像erlang",{"_index":189,"title":{},"content":{"9":{}},"tags":{}}],["world希望能够通过一些创新探索，构建起一个更好的互操作平台，使得上面的应用之间可以更好地协作，它看起来像是基于osi",{"_index":134,"title":{},"content":{"7":{}},"tags":{}}],["world当作输入，然后按照程序构造的逻辑去检索相应的组件并组合构造，这样的程序要么是构造不出来的，要么就是至少能够成功运行的，而剩下的正确性问题就取决于组件描述的准确性和ai",{"_index":208,"title":{},"content":{"14":{}},"tags":{}}],["world提供的不是一个单个plugin，而是一种通用编程能力，它可以理解为是一种面向ai的编程系统，因为ai发出的文本序列，会被r",{"_index":207,"title":{},"content":{"14":{}},"tags":{}}],["world是一个像区块链类似的分布式系统；同时，即使是在源代码的翻译解释部分，real",{"_index":11,"title":{},"content":{"3":{}},"tags":{}}],["world涉及到很多技术思维，甚至包含一些创新尝试，我相信参与这个项目本身肯定会学到很多知识。但现阶段还不能正式公布，我们预计会在6",{"_index":223,"title":{},"content":{"18":{}},"tags":{}}],["world的架构，那个时候的热点还是元宇宙。那个时候，由于没有现在大模型的这种能力，我们当然也没有主要去思考ai方面的，但是从我们自己的设计思路上，我和我们公司的2号员工，在2020年的时候就思考和讨论将来怎样让ai",{"_index":196,"title":{},"content":{"12":{}},"tags":{}}],["world的核心是一套运行时，可以部分理解为一个虚拟机，但是与传统单纯解释源代码的编程语言的虚拟机相比，它包含一些源代码解释翻译之外的功能，例如权限验证、沙盒安全与互操作、分布式内容分发与同步、组件的依赖管理和动态加载等等，因此可以理解为real",{"_index":10,"title":{},"content":{"3":{}},"tags":{}}],["world的理念甚至是相反的，从名字就可以看出，我选择reality这个词，是希望我们能够引导用户更多关注现实，r",{"_index":16,"title":{},"content":{"4":{}},"tags":{}}],["world的目标是希望通过提供更简化、更具互操作性的一些编程体验，使更多的人能够随心所欲地表达ta",{"_index":17,"title":{},"content":{"4":{}},"tags":{}}],["world的目标跟tim的一些描述和愿景是相似的，但也存在比较大的根本不同，我首先描述跟tim演讲的一些关系和逻辑，然后再介绍我们的思考，通过这些问题就可以比较自然地理解r",{"_index":28,"title":{},"content":{"5":{}},"tags":{}}],["world的第二个核心关注点和基础就是在这两个方面做出了一些新的探索。世界上只有大约不到0.5%的人是会编写代码的，约3000万左右，所以数字化表达的潜力还远远没有被发挥出来。如果我们将这个数字提升到5亿~10",{"_index":135,"title":{},"content":{"8":{}},"tags":{}}],["world的设计过程中，为了要让普遍用户可以构造程序，将程序的整个构造过程做了多处调整，从类型定义，数据初始化和管理，互操作性，程序结构的推演，线程隔离等等。其中还有一个重要的方面就是组合性，这种组合性使得两个相关的组件，不需要用户手动添加任何参数或者输入输出的设置，就可以正确地构造程序，例如如下的这段复杂的逻辑，整个graph",{"_index":201,"title":{},"content":{"13":{}},"tags":{}}],["world还处于非常早期和原型的阶段，我预计还会再迭代几个版本到v0.5.0左右才会开始正式公布或者内测，所以这里我也不会涉及太多技术细节，但是我可以分享我们想解决什么问题，以及为什么要解决这些问题，并大概说明一些思路，这样大家应该能够初步了解real",{"_index":6,"title":{},"content":{"1":{}},"tags":{}}],["wrote",{"_index":149,"title":{},"content":{"9":{}},"tags":{}}],["xml",{"_index":81,"title":{},"content":{"5":{}},"tags":{}}]],"pipeline":["stemmer"]}}